<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_YSrkcH_6EeSOLqU6j-e_hg" name="ComputerSystem">
    <ownedComment xmi:type="uml:Comment" xmi:id="_CJt34BB2EeWr3Pbi51wSsA">
      <body>Open diagram &quot;CSD | Top&quot; for structure exploration.</body>
    </ownedComment>
    <packageImport xmi:type="uml:PackageImport" xmi:id="_pl3jgH_6EeSOLqU6j-e_hg">
      <importedPackage xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </packageImport>
    <packageImport xmi:type="uml:PackageImport" xmi:id="_p7pmQH_6EeSOLqU6j-e_hg">
      <importedPackage xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </packageImport>
    <packageImport xmi:type="uml:PackageImport" xmi:id="_0MfxQIB5EeSeANT-DfY5oA">
      <importedPackage xmi:type="uml:Model" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_DV8nkBv8EduZN5aJJITI5w"/>
    </packageImport>
    <packagedElement xmi:type="uml:Package" xmi:id="_PlgQIICCEeSeANT-DfY5oA" name="Computer">
      <packagedElement xmi:type="uml:Class" xmi:id="_fMulcH_6EeSOLqU6j-e_hg" name="Computer" classifierBehavior="_2cxfEICrEeSYmJvm6id8mw" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_p_mqAIB6EeSeANT-DfY5oA" name="usbBus" visibility="protected" type="_ZUBdgIB6EeSeANT-DfY5oA" aggregation="shared">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_p_mqAYB6EeSeANT-DfY5oA"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_p_mqAoB6EeSeANT-DfY5oA" value="2"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_dmbmsICiEeSeANT-DfY5oA" name="frame" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_TWVjwGtVEeSCmtGQ-V4nzg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_NFL2YICsEeSYmJvm6id8mw" name="timer" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_UiB-AIFSEeSxK_Fl3WspFw" name="timerId" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_oyJrcIFWEeSxK_Fl3WspFw" name="usbPort" visibility="public" type="_6tx6sIB-EeSeANT-DfY5oA" aggregation="composite" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_lIYI8MOwEeSxS9_G15_gSg" value="2"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_lIcaYMOwEeSxS9_G15_gSg" value="2"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_m1ajcMO5EeSxS9_G15_gSg" name="userPort" type="_vOIpQMO2EeSxS9_G15_gSg" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_EFn4sMO7EeSxS9_G15_gSg" name="driverManager" visibility="protected" type="_2WM7UMO6EeSxS9_G15_gSg" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_yYoMwMXOEeSsD5C2f30z-g" name="resMgr" visibility="protected" type="_sSppwMQdEeSirL7ina4YrA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Q9Z2oMbgEeSvmLj5mtpd2g" name="printerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_YyYO0MbgEeSvmLj5mtpd2g" name="storageID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_c8b1UOqLEeSlmKRr_VnIAg" name="application" visibility="protected" type="_N2fr8MOyEeSxS9_G15_gSg" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_EcxMAOqMEeSlmKRr_VnIAg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_EcxzEOqMEeSlmKRr_VnIAg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_lz0-ABUjEeWFQ7RnHw84Pw" name="numSec" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_c-lZQC_KEeW9MYT2X2gffg" name="dummy">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_SHmf8MXPEeSsD5C2f30z-g" name="Connector3">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_SHnHAMXPEeSsD5C2f30z-g" partWithPort="_EFn4sMO7EeSxS9_G15_gSg" role="_pCSIcMXOEeSsD5C2f30z-g">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_SHnHAcXPEeSsD5C2f30z-g" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_SHnHAsXPEeSsD5C2f30z-g" value="1"/>
          </end>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_SHnuEMXPEeSsD5C2f30z-g" role="_yYoMwMXOEeSsD5C2f30z-g">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_SHnuEcXPEeSsD5C2f30z-g" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_SHnuEsXPEeSsD5C2f30z-g" value="1"/>
          </end>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_AtlvEOqNEeSlmKRr_VnIAg" name="Connector4">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_AtoyYOqNEeSlmKRr_VnIAg" role="_m1ajcMO5EeSxS9_G15_gSg"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_AtpZcOqNEeSlmKRr_VnIAg" partWithPort="_c8b1UOqLEeSlmKRr_VnIAg" role="_5Gm08MYAEeSsD5C2f30z-g"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_BzuQsOqNEeSlmKRr_VnIAg" name="Connector5">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_Bzu3wOqNEeSlmKRr_VnIAg" partWithPort="_c8b1UOqLEeSlmKRr_VnIAg" role="_JKtYAMQPEeSirL7ina4YrA"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_Bzve0OqNEeSlmKRr_VnIAg" partWithPort="_EFn4sMO7EeSxS9_G15_gSg" role="_w7EMQMbDEeSvmLj5mtpd2g"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_MWa08O1iEeSNVueSbviXfA" name="Connector6">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_MWfGYO1iEeSNVueSbviXfA" partWithPort="_p_mqAIB6EeSeANT-DfY5oA" role="_ui7KkICCEeSeANT-DfY5oA"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_MWftcO1iEeSNVueSbviXfA" role="_oyJrcIFWEeSxK_Fl3WspFw"/>
        </ownedConnector>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_2cxfEICrEeSYmJvm6id8mw" name="Computer_SM" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_3ifJ8ICrEeSYmJvm6id8mw" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_oEwucMYJEeSsD5C2f30z-g" name="Initialise" source="_75RkAICrEeSYmJvm6id8mw" target="_JoagwMYJEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_3U_ckMbgEeSvmLj5mtpd2g" name="initializing">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_YgBNUO4NEeSAlbC0LA6o5Q" name="onResMgrRunning" source="_JoagwMYJEeSsD5C2f30z-g" target="_gMdQYO4UEeSJPsWo_Mnp3w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Lk1o8O4QEeSJPsWo_Mnp3w" name="resMgrRunning">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;::{resMgrRunning}] is now accepting requests &quot;;

if ( resMgr.requestPrinterDriver().send() ) {
	std::cout &lt;&lt; &quot; -- requesting for a printer driver.&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; -- FAILed to request a printer driver!&quot; &lt;&lt; std::endl;
}
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_-4G3oO4PEeSJPsWo_Mnp3w" name="onResMgr_resMgrRunning" event="_zJOOoO4PEeSJPsWo_Mnp3w" port="_yYoMwMXOEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_AGqnYO4OEeSAlbC0LA6o5Q" name="EX_InitUSB_Continuation" source="_KlKcAO4NEeSAlbC0LA6o5Q" target="_5D02wO4NEeSAlbC0LA6o5Q"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_75RkAICrEeSYmJvm6id8mw" name="Initial1"/>
            <subvertex xmi:type="uml:State" xmi:id="_JoagwMYJEeSsD5C2f30z-g" name="WaitForResourceManager">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_t4bf4O4OEeSAlbC0LA6o5Q" name="waitForResMgr">
                <language>C++</language>
                <body>time_t currentTime ;&#xD;
struct tm *localTime;&#xD;
time( &amp;currentTime );&#xD;
localTime = localtime( &amp;currentTime );&#xD;
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;&#xD;
&#xD;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {WaitForResourceManager}, waiting for resource manager initalization&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_rcvLcO4MEeSAlbC0LA6o5Q" name="InitUSBBus">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_KlKcAO4NEeSAlbC0LA6o5Q" name="EX_initUSB" kind="exitPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_gMdQYO4UEeSJPsWo_Mnp3w" name="EN_initUSB" kind="entryPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_E2O74A7eEeWWHqV5N_7gJQ" name="initUSBBus">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {InitUSBBus}, waiting for the USB bus to be initialized.&quot; &lt;&lt; std::endl;</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_FtPDwe4NEeSAlbC0LA6o5Q" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_ELcfsMbjEeSvmLj5mtpd2g" name="onPrintResourceID" source="_HrCd8MbhEeSvmLj5mtpd2g" target="_Bt8igMbjEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ekrn0MbkEeSvmLj5mtpd2g" name="importPrinterDriver_requestStorageDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] &quot;;

if ( timer.cancelTimer( timerId ) ) {
	std::cout &lt;&lt; &quot;timer canceled&quot;;
} else {
	std::cout &lt;&lt; &quot;ERROR canceling timer&quot;;
}

printerID = (UMLRTCapsuleId) *rtdata;

if ( printerID.isValid() ) {
	if ( frame.import( printerID, usbBus,  0) ) {
		std::cout &lt;&lt; &quot; and successfully imported the printer driver&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; and FAILed to import the printer driver&quot; &lt;&lt; std::endl;
	}
} else {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and received an INVALID printerID!&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_rhWIAMbjEeSvmLj5mtpd2g" name="onResourceID" event="_WOVBgMQeEeSirL7ina4YrA" port="_yYoMwMXOEeSsD5C2f30z-g"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WgJK0O4OEeSAlbC0LA6o5Q" name="EN_initUSB_Continuation" source="_gMdQYO4UEeSJPsWo_Mnp3w" target="_HrCd8MbhEeSvmLj5mtpd2g"/>
                <transition xmi:type="uml:Transition" xmi:id="_Y-ulwO4REeSJPsWo_Mnp3w" name="onPrintDriverTimeout" source="_HrCd8MbhEeSvmLj5mtpd2g" target="_Bt8igMbjEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZIsvMO4TEeSJPsWo_Mnp3w" name="Timeout_NoResponse">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] timed out while waiting for a printerId&quot; &lt;&lt; std::endl;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_L1TmgO4TEeSJPsWo_Mnp3w" name="onTimeout" port="_NFL2YICsEeSYmJvm6id8mw">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_Huz1wO4UEeSJPsWo_Mnp3w" name="onStorageTimeout" source="_Bt8igMbjEeSvmLj5mtpd2g" target="_KlKcAO4NEeSAlbC0LA6o5Q">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_PgxWMO4UEeSJPsWo_Mnp3w" name="onStorageTimeout">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot; timed out waiting to receive a storageId&quot; &lt;&lt; std::endl;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="__CiaQMbkEeSvmLj5mtpd2g" name="onStorageResourceID" source="_Bt8igMbjEeSvmLj5mtpd2g" target="_KlKcAO4NEeSAlbC0LA6o5Q">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_sYYgoMeGEeSz1oN1Kl4Now" name="importStorageDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] &quot;;

if ( timer.cancelTimer( timerId ) ) {
	std::cout &lt;&lt; &quot;timer canceled&quot;;
} else {
	std::cout &lt;&lt; &quot;ERROR canceling timer&quot;;
}

storageID = (UMLRTCapsuleId) *rtdata;

if ( storageID.isValid() ) {
	if ( frame.import( storageID, usbBus, 1)) {
		std::cout &lt;&lt; &quot; and storage is now available.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but FAILed to import storage driver!&quot; &lt;&lt; std::endl;
	}
} else {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;but received INVALID storageID!&quot; &lt;&lt; std::endl;
}</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_436aYO1MEeSAm9oTc70yKg" name="onResourceId" event="_WOVBgMQeEeSirL7ina4YrA" port="_yYoMwMXOEeSsD5C2f30z-g"/>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_HrCd8MbhEeSvmLj5mtpd2g" name="WaitForPrinter">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_4dTQAO4SEeSJPsWo_Mnp3w" name="setTimer">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] &quot;;

numSec = 10;
timerId = timer.informIn( UMLRTTimespec( numSec, 0 ) );

if ( timerId.isValid() ) {
	std::cout &lt;&lt; &quot; sets a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer&quot; &lt;&lt; std::endl;
}
else {
	std::cout &lt;&lt; &quot; FAILed to set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer!&quot; &lt;&lt; std::endl;
}
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_Bt8igMbjEeSvmLj5mtpd2g" name="WaitForStorage">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_7xknsO4TEeSJPsWo_Mnp3w" name="requestStorageDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {WaitForStorage} &quot;;

/**
 * Send storage request
 */
if ( resMgr.requestStorageDriver().send() ) {
	std::cout &lt;&lt; &quot;and requested a storage driver&quot;;
} else {
	std::cout &lt;&lt; &quot;FAILed to request a storage driver&quot;;
}

/**
 * Set timeout for storage request
 */
numSec = 10;
timerId = timer.informIn( UMLRTTimespec( numSec, 0 ) );
if ( timerId.isValid() ) {
	std::cout &lt;&lt; &quot; set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer waiting for a storageDriver.&quot; &lt;&lt; std::endl;
}
else {
	std::cout &lt;&lt; &quot; FAILed to set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer!&quot; &lt;&lt; std::endl;
}
</body>
                  </entry>
                </subvertex>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_5D02wO4NEeSAlbC0LA6o5Q" name="Running">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_Aj9CgO4dEeSJPsWo_Mnp3w" name="running">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {Running}.&quot; &lt;&lt; std::endl;

//context()->debugOutputModel();

</body>
              </entry>
            </subvertex>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_2WM7UMO6EeSxS9_G15_gSg" name="ResourceManager" visibility="public" classifierBehavior="_j6H2YMQOEeSirL7ina4YrA" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_-hXZwMQZEeSirL7ina4YrA" name="frame" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_TWVjwGtVEeSCmtGQ-V4nzg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_PPdAUMQdEeSirL7ina4YrA" name="usbPrinterDriver" visibility="protected" type="_ZUBdgIB6EeSeANT-DfY5oA" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_SJE40MQdEeSirL7ina4YrA"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_SJHVEMQdEeSirL7ina4YrA" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_a5T_YMQdEeSirL7ina4YrA" name="usbStorageDriver" visibility="protected" type="_ZUBdgIB6EeSeANT-DfY5oA" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_f56LcMQdEeSirL7ina4YrA"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_f58nsMQdEeSirL7ina4YrA" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_SUYb4MXIEeSsD5C2f30z-g" name="printerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_myrFAMXIEeSsD5C2f30z-g" name="storageID" visibility="protected">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_pCSIcMXOEeSsD5C2f30z-g" name="resMgr" type="_sSppwMQdEeSirL7ina4YrA" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_3NAL0MX8EeSsD5C2f30z-g" name="printerRequestCount" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_BdingMX9EeSsD5C2f30z-g"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_EgcX0MX9EeSsD5C2f30z-g" name="storageRequestCount" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_IAhzYMX9EeSsD5C2f30z-g"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_w7EMQMbDEeSvmLj5mtpd2g" name="appPort" type="_sSppwMQdEeSirL7ina4YrA" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_yMNRsMeMEeSz1oN1Kl4Now" name="status" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_7___oMePEeSz1oN1Kl4Now" name="resourceType" visibility="protected" type="_e2WAMMQeEeSirL7ina4YrA" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_Nf-gUA4XEeWZmqO69MGcNA" name="timer" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_1b94QA4XEeWZmqO69MGcNA" name="timerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_40hD4BUnEeWFQ7RnHw84Pw" name="numSec" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_j6H2YMQOEeSirL7ina4YrA" name="ResourceManager_SM" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_lPuXYMQOEeSirL7ina4YrA" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_vAwzoMQOEeSirL7ina4YrA" name="initialize" source="_rMOyEMQOEeSirL7ina4YrA" target="_vjKL0MeMEeSz1oN1Kl4Now">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_NM_EQMXIEeSsD5C2f30z-g" name="Initialize">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing&quot;;

/**
 * In this version, we will initialize just the resources that are required for the demo.
 * This capsule could be made more intelligent by implemented managed pools.
 */

bool localPrinterStatus;
bool localStorageStatus;
bool localTimerStatus;

printerID = frame.incarnate(usbPrinterDriver, USBPrinterDriver);
localPrinterStatus = printerID.isValid();
if ( localPrinterStatus ) {
	std::cout &lt;&lt; &quot; - printer driver ready&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; - ERROR instantiating printer driver&quot; &lt;&lt; std::endl;
}

time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing&quot;;

storageID = frame.incarnate(usbStorageDriver, USBStorageDriver);
localStorageStatus = storageID.isValid();
if ( localStorageStatus ) {
	std::cout &lt;&lt; &quot; - storage driver ready&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; - ERROR instantiating storage driver&quot; &lt;&lt; std::endl;
}

status = ( localPrinterStatus &amp;&amp; localStorageStatus);

if (status) {

	time( &amp;currentTime );
	localTime = localtime( &amp;currentTime );
	std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing - &quot;;

	numSec = 10;

	timerID = timer.informIn(UMLRTTimespec(numSec,0));
	localTimerStatus = timerID.isValid();
	if ( ! localTimerStatus ) {
		std::cout &lt;&lt; &quot;FAILED to &quot;;
	}
	std::cout &lt;&lt; &quot;set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer for drivers initialization.&quot; &lt;&lt; std::endl;
}
status = ( localPrinterStatus &amp;&amp; localStorageStatus &amp;&amp; localTimerStatus);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_HSfeIMX8EeSsD5C2f30z-g" name="onResMgrPrinterRequest" source="_uPDp4MQOEeSirL7ina4YrA" target="_uPDp4MQOEeSirL7ina4YrA">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_V1YDUMX9EeSsD5C2f30z-g" name="Printer requested">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_V1YDUcX9EeSsD5C2f30z-g">
                  <language>C++</language>
                  <body>return( resourceType == PrinterDriver);
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_iA5vkMX-EeSsD5C2f30z-g" name="sendResMgrPrinterResource">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] printer resource requested by computer,&quot;;

if ( printerID.isValid() ) {
	if ( resMgr.resourceID( printerID ).send() ) {
		std::cout &lt;&lt; &quot; and sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but ERROR sending printer resource!&quot; &lt;&lt; std::endl;
	}
} else {
	if ( resMgr.resNotAvail().send() ) {
		std::cout &lt;&lt; &quot; but printer resource not available sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but ERROR sending printer resource not available!&quot; &lt;&lt; std::endl;
	}
}

</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_PGl6IA8aEeWl7ddVi7dGGQ" name="onRequestPrinter" event="_qNNNAA8YEeWl7ddVi7dGGQ" port="_pCSIcMXOEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_IlhzUMX8EeSsD5C2f30z-g" name="onResMgrStorageRequest" source="_uPDp4MQOEeSirL7ina4YrA" target="_uPDp4MQOEeSirL7ina4YrA">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_P4ZcoMX_EeSsD5C2f30z-g" name="StorageRequested">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_P4ZcocX_EeSsD5C2f30z-g">
                  <language>C++</language>
                  <body>return( resourceType == StorageDriver);
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_095lEMX-EeSsD5C2f30z-g" name="sendResMgrStorageResource">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] storage resource requested by Computer,&quot;;

if ( storageID.isValid() ) {
	if ( resMgr.resourceID( storageID ).send() ) {
		std::cout &lt;&lt; &quot; and sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but ERROR sending storage resource!&quot; &lt;&lt; std::endl;
	}
} else {
	if ( resMgr.resNotAvail().send() ) {
		std::cout &lt;&lt; &quot; but storage resource not available sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but ERROR sending storage resource not available&quot; &lt;&lt; std::endl;
	}
}
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_YwcJQA8aEeWl7ddVi7dGGQ" name="onStorageRequest" event="_vbaXQA8YEeWl7ddVi7dGGQ" port="_pCSIcMXOEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_EC_bIMePEeSz1oN1Kl4Now" name="OK" guard="_TkG_oMePEeSz1oN1Kl4Now" source="_vjKL0MeMEeSz1oN1Kl4Now" target="_p3iWUA4YEeWZmqO69MGcNA">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_TkG_oMePEeSz1oN1Kl4Now" name="SuccesfulInitialization">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_TkG_ocePEeSz1oN1Kl4Now">
                  <language>C++</language>
                  <body>return( status );</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_qLX1kPBOEeSy0dZlYL7EHw" name="InstantiateSuccess">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] drivers instantiated.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_JN9rMMePEeSz1oN1Kl4Now" name="NOK" guard="_Z32OkMePEeSz1oN1Kl4Now" source="_vjKL0MeMEeSz1oN1Kl4Now" target="_Eytn4MePEeSz1oN1Kl4Now">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_Z32OkMePEeSz1oN1Kl4Now" name="FailedInitialization">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_Z32OkcePEeSz1oN1Kl4Now">
                  <language>C++</language>
                  <body>return ( ! status );</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_jXgVEPBOEeSy0dZlYL7EHw" name="InitiFailed">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] FAILed to initialize!&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_we32sA4YEeWZmqO69MGcNA" name="onTimeout" source="_p3iWUA4YEeWZmqO69MGcNA" target="_uPDp4MQOEeSirL7ina4YrA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_T_5GEA5DEeWfxoP9jGN4_w" name="broadcastReady">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

/**
 * Telling the world that the ResourceManager is taking requests!
 */
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] &quot;;

if ( resMgr.resMgrRunning().send() ) {
	std::cout &lt;&lt; &quot;told &quot;;
	
} else {
	std::cout &lt;&lt; &quot;FAILED to tell &quot;;
}
std::cout &lt;&lt; &quot;its clients that it is taking requests.&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_uq1UIA5CEeWfxoP9jGN4_w" name="onTimeout" port="_Nf-gUA4XEeWZmqO69MGcNA">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_1apD4A8aEeWl7ddVi7dGGQ" name="onAppPrinterRequest" source="_uPDp4MQOEeSirL7ina4YrA" target="_uPDp4MQOEeSirL7ina4YrA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_BXI1oA8cEeWl7ddVi7dGGQ" name="sendAppPortPrinterResource">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] printer resource requested by App,&quot;;

if ( printerID.isValid() ) {
	if ( resMgr.resourceID( printerID ).send() ) {
		std::cout &lt;&lt; &quot; and sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but got an ERROR sending!&quot; &lt;&lt; std::endl;
	}
} else {
	if ( resMgr.resNotAvail().send() ) {
		std::cout &lt;&lt; &quot;[ but printer resource is not available sent&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot;but ERROR sending printer resource not available&quot; &lt;&lt; std::endl;
	}
}

</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_mDNKYA8bEeWl7ddVi7dGGQ" name="onAppPrinterRequest" event="_qNNNAA8YEeWl7ddVi7dGGQ" port="_w7EMQMbDEeSvmLj5mtpd2g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_sfIsAA8bEeWl7ddVi7dGGQ" name="onAppPortStorageRequest" source="_uPDp4MQOEeSirL7ina4YrA" target="_uPDp4MQOEeSirL7ina4YrA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fybTYA8cEeWl7ddVi7dGGQ" name="sendAppPortStorageResource">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] storage resource requested by App,&quot;;

if ( storageID.isValid() ) {
	if ( appPort.resourceID( storageID ).send() ) {
		std::cout &lt;&lt; &quot; and sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot; but ERROR sending storage resource!&quot; &lt;&lt; std::endl;
	}
} else {
	if ( appPort.resNotAvail().send() ) {
		std::cout &lt;&lt; &quot; but storage resource not available sent.&quot; &lt;&lt; std::endl;
	} else {
		std::cout &lt;&lt; &quot;but ERROR sending storage resource not available!&quot; &lt;&lt; std::endl;
	}
}
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_JvPTkA8dEeWl7ddVi7dGGQ" name="onAppPortStorageRequest" event="_vbaXQA8YEeWl7ddVi7dGGQ" port="_w7EMQMbDEeSvmLj5mtpd2g"/>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_rMOyEMQOEeSirL7ina4YrA" name="Initial1"/>
            <subvertex xmi:type="uml:State" xmi:id="_uPDp4MQOEeSirL7ina4YrA" name="WaitingForRequest">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_YOXT8O0NEeSzlZWHZcnPXA" name="waitingForRequest">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {WaitingForRequest},  waiting for a request&quot; &lt;&lt; std::endl;
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_m4LMsA7dEeWWHqV5N_7gJQ" name="requestReceived">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] received a request!&quot; &lt;&lt; std::endl;
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_vjKL0MeMEeSz1oN1Kl4Now" name="instantiateOK" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_Eytn4MePEeSz1oN1Kl4Now" name="InitFail">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_QH-LUA7dEeWWHqV5N_7gJQ" name="initFailState">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {InitFail}&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_p3iWUA4YEeWZmqO69MGcNA" name="WaitInitTimeout" visibility="package">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_5nGcIA48EeWfxoP9jGN4_w" name="waitOnTimeout">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in state {WaitInitTimeout}&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_T45j8PBMEeSy0dZlYL7EHw" client="_fMulcH_6EeSOLqU6j-e_hg" supplier="_e2WAMMQeEeSirL7ina4YrA"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_eZl7gPBMEeSy0dZlYL7EHw" client="_fMulcH_6EeSOLqU6j-e_hg">
        <supplier xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_ev0DIPBMEeSy0dZlYL7EHw" client="_fMulcH_6EeSOLqU6j-e_hg">
        <supplier xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IWYV4G6NEeSyDdTKostG4Q"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_saNisPWTEeSqKZdqtEmi8Q" client="_2WM7UMO6EeSxS9_G15_gSg" supplier="_z6QQYMOFEeSSS8SwKHucgQ"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_tKPRcPWTEeSqKZdqtEmi8Q" client="_2WM7UMO6EeSxS9_G15_gSg" supplier="_vk5ZsMOFEeSSS8SwKHucgQ"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_lRFDsMOJEeSSS8SwKHucgQ" name="Software">
      <packagedElement xmi:type="uml:Class" xmi:id="_9YrV0MOJEeSSS8SwKHucgQ" name="Application" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WvYkUMQXEeSirL7ina4YrA" name="applicationType" visibility="protected" type="_5luYcMQUEeSirL7ina4YrA" aggregation="composite" association="_ZtZPwAiCEeWmptSG6Ct2-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_N2fr8MOyEeSxS9_G15_gSg" name="WordProcessorApp" visibility="public" classifierBehavior="_tFC1oMYCEeSsD5C2f30z-g" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_JKtYAMQPEeSirL7ina4YrA" name="resourcePort" visibility="public" type="_sSppwMQdEeSirL7ina4YrA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_oyefIMYAEeSsD5C2f30z-g" name="frame" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_TWVjwGtVEeSCmtGQ-V4nzg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_5Gm08MYAEeSsD5C2f30z-g" name="UserControlePort" type="_vOIpQMO2EeSxS9_G15_gSg" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_I8yqgMYBEeSsD5C2f30z-g" name="deviceInterface" visibility="protected" type="_ZUBdgIB6EeSeANT-DfY5oA" aggregation="shared">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_QtCTsMYBEeSsD5C2f30z-g"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_QtEI4MYBEeSsD5C2f30z-g" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_jacOAMYBEeSsD5C2f30z-g" name="usbPort" visibility="public" type="_6tx6sIB-EeSeANT-DfY5oA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_L0QU8MYDEeSsD5C2f30z-g" name="document" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_5lVhgBydEduyofBvg4RL2w"/>
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_g98OMBRUEeW80tAMjGoZKg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_g9-DYBRUEeW80tAMjGoZKg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_urYxMMbaEeSvmLj5mtpd2g" name="printerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_RCE7AMd_EeSz1oN1Kl4Now" name="progress" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_uUaXMMeAEeSz1oN1Kl4Now" name="storageID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Ev3W8MeJEeSz1oN1Kl4Now" name="importOK" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_Mt-r4O0LEeSzlZWHZcnPXA" name="log" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_9cNTsO1GEeSZmPHiHLCOIw" name="status" visibility="protected">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_rNb0gAiBEeWmptSG6Ct2-w" name="apptype" type="_5luYcMQUEeSirL7ina4YrA" redefinedProperty="_WvYkUMQXEeSirL7ina4YrA">
          <defaultValue xmi:type="uml:InstanceValue" xmi:id="_-U2_EAiGEeWmptSG6Ct2-w" type="_5luYcMQUEeSirL7ina4YrA" instance="_7OV8EMQUEeSirL7ina4YrA"/>
        </ownedAttribute>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_xN9oQMYBEeSsD5C2f30z-g" name="Connector1">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_xN-PUMYBEeSsD5C2f30z-g" role="_jacOAMYBEeSsD5C2f30z-g">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_xN-PUcYBEeSsD5C2f30z-g" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_xN-PUsYBEeSsD5C2f30z-g" value="1"/>
          </end>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_xN-PU8YBEeSsD5C2f30z-g" partWithPort="_I8yqgMYBEeSsD5C2f30z-g" role="_vXWH4MXgEeSsD5C2f30z-g">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_xN-PVMYBEeSsD5C2f30z-g" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_xN-PVcYBEeSsD5C2f30z-g" value="1"/>
          </end>
        </ownedConnector>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_tFC1oMYCEeSsD5C2f30z-g" name="WordProcessorApp_SM" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_vz1-MMYCEeSsD5C2f30z-g" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_Ee0YcMYDEeSsD5C2f30z-g" name="Initial" source="_AE38sMYDEeSsD5C2f30z-g" target="_DcG-QMYDEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_EWxlsMeCEeSz1oN1Kl4Now" name="initializingApplication">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );

document = (char *) malloc(101);
strcpy(document, &quot;Aenean lacinia bibendum nulla sed consectetur.\0\0&quot;);

std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is initializing and document contains string \&quot;&quot; &lt;&lt; document &lt;&lt; &quot;\&quot;.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_SaU0kMYEEeSsD5C2f30z-g" name="onCreateDoc" source="_DcG-QMYDEeSsD5C2f30z-g" target="_DcG-QMYDEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_pfv4AMYEEeSsD5C2f30z-g" name="createDocument">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] document created with provided string.&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_Xyz7AOqJEeSlmKRr_VnIAg" name="onCreateDocument" event="_tb9rkMO3EeSxS9_G15_gSg" port="_5Gm08MYAEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_thYhcMYEEeSsD5C2f30z-g" name="onAddToDoc" source="_DcG-QMYDEeSsD5C2f30z-g" target="_DcG-QMYDEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_6vVwgMYEEeSsD5C2f30z-g" name="addString">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] String added to document.&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_z2uToAiDEeWmptSG6Ct2-w" name="onAddToDoc" event="_efZJIMO4EeSxS9_G15_gSg" port="_5Gm08MYAEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_QNf7MMYFEeSsD5C2f30z-g" name="onPrintDocument" source="_DcG-QMYDEeSsD5C2f30z-g" target="_yNH0kMbEEeSvmLj5mtpd2g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_CCoQkMYIEeSsD5C2f30z-g" name="printDocumentRequest">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] received request to print the document&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_AchD0MYHEeSsD5C2f30z-g" name="onPrintDocument" event="_0zt8QMO3EeSxS9_G15_gSg" port="_5Gm08MYAEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_boq-AMYFEeSsD5C2f30z-g" name="printComplete_cont" source="_ND7NAMbHEeSvmLj5mtpd2g" target="_DcG-QMYDEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZvcWEMYGEeSsD5C2f30z-g" name="printComplete">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is done printing&quot;;

if ( frame.deport(printerID, deviceInterface) ) {
	std::cout &lt;&lt; &quot; - printer driver released.&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; - FAILed to release the printer driver!&quot; &lt;&lt; std::endl;
}
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_edA1MMbGEeSvmLj5mtpd2g" name="printerUnavailable" source="_bshqkMbGEeSvmLj5mtpd2g" target="_DcG-QMYDEeSsD5C2f30z-g"/>
            <transition xmi:type="uml:Transition" xmi:id="_cuGPwMbbEeSvmLj5mtpd2g" name="onSaveDocument" source="_DcG-QMYDEeSsD5C2f30z-g" target="_WVfH4MbbEeSvmLj5mtpd2g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_a2JHAMeIEeSz1oN1Kl4Now" name="saveDocumentRequest">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] received request to save the document&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_ksVxUMbeEeSvmLj5mtpd2g" name="onSaveDocument" event="_931oIMO3EeSxS9_G15_gSg" port="_5Gm08MYAEeSsD5C2f30z-g"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_dVXrIMbbEeSvmLj5mtpd2g" name="StorageNotAvailable" source="_W86UQMbbEeSvmLj5mtpd2g" target="_DcG-QMYDEeSsD5C2f30z-g"/>
            <transition xmi:type="uml:Transition" xmi:id="_eHXv0MbbEeSvmLj5mtpd2g" name="saveComplete_cont" source="_XUhjAMbbEeSvmLj5mtpd2g" target="_DcG-QMYDEeSsD5C2f30z-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rV5iMMeBEeSz1oN1Kl4Now" name="saveComplete">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is done saving&quot;;

if ( frame.deport(storageID, deviceInterface) ) {
	std::cout &lt;&lt; &quot; - storage driver released.&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; - FAILed to release the storage driver!&quot; &lt;&lt; std::endl;
}
</body>
              </effect>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_AE38sMYDEeSsD5C2f30z-g" name="Initial1"/>
            <subvertex xmi:type="uml:State" xmi:id="_DcG-QMYDEeSsD5C2f30z-g" name="WaitingForCommand">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_F_0I8BbHEeWa4sJtLVaM7A" name="waitingForCommand_EN">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is {WaitingForCommand}.&quot; &lt;&lt; std::endl;
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_D3UosMYFEeSsD5C2f30z-g" name="Printing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_yNH0kMbEEeSvmLj5mtpd2g" name="EntryPoint1" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_bshqkMbGEeSvmLj5mtpd2g" name="ExitPoint1" kind="exitPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_ND7NAMbHEeSvmLj5mtpd2g" name="ExitPoint2" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ffx8MBbHEeWa4sJtLVaM7A" name="printing_EN">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is {Printing}.&quot; &lt;&lt; std::endl;
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_yM6ZMMbEEeSvmLj5mtpd2g" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_7uSo0MbEEeSvmLj5mtpd2g" name="getPrinter" source="_yNH0kMbEEeSvmLj5mtpd2g" target="_6wgK4MbEEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_J8zV8MbFEeSvmLj5mtpd2g" name="requestPrinterDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]&quot;;

if ( resourcePort.requestPrinterDriver().send() ) {
	std::cout &lt;&lt; &quot; requested a printer driver&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; FAILed to  request a printer driver&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_OpTE0MbGEeSvmLj5mtpd2g" name="onPrintResource" source="_6wgK4MbEEeSvmLj5mtpd2g" target="_9b6ywMeJEeSz1oN1Kl4Now">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_hD2kgMbaEeSvmLj5mtpd2g" name="importPrinterDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]&quot;;

printerID = (UMLRTCapsuleId) *rtdata;

if ( printerID.isValid() ) {
	importOK = frame.import ( printerID, deviceInterface );
	std::cout &lt;&lt; &quot; importing a printer driver.&quot; &lt;&lt; std::endl;
} else {
	importOK = false;
	std::cout &lt;&lt; &quot; received an invalid Printer ID&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_RJQJAMbaEeSvmLj5mtpd2g" name="onResourceID" event="_WOVBgMQeEeSirL7ina4YrA" port="_JKtYAMQPEeSirL7ina4YrA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_c4pfcMbGEeSvmLj5mtpd2g" name="onResNotAvail" source="_6wgK4MbEEeSvmLj5mtpd2g" target="_bshqkMbGEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Dvz-QMeAEeSz1oN1Kl4Now" name="printResourceNotAvailable">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] print driver not available&quot; &lt;&lt; std::endl;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_l8GW8O4YEeSJPsWo_Mnp3w" name="onResNotAvail" event="_AFeJgMXKEeSsD5C2f30z-g" port="_JKtYAMQPEeSirL7ina4YrA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_T22ngMYFEeSsD5C2f30z-g" name="onPrintStatus" source="_mZ_S0MbGEeSvmLj5mtpd2g" target="_h1RbUMeTEeSz1oN1Kl4Now">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_9-zoAMbGEeSvmLj5mtpd2g" name="getProgress">
                    <language>C++</language>
                    <body>progress = (int) *rtdata;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_4OrnAMbHEeSvmLj5mtpd2g" name="onStatus" event="_2QT44MXiEeSsD5C2f30z-g" port="_jacOAMYBEeSsD5C2f30z-g"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_SW2fMMbHEeSvmLj5mtpd2g" name="printCompleted" guard="_EDWH4MbIEeSvmLj5mtpd2g" source="_h1RbUMeTEeSz1oN1Kl4Now" target="_ND7NAMbHEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_EDWH4MbIEeSvmLj5mtpd2g" name="progress_GTE_100">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_EDWH4cbIEeSvmLj5mtpd2g">
                      <language>C++</language>
                      <body>return( progress >= 100);
</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_EZ8vYMbbEeSvmLj5mtpd2g" name="releasePrinterDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] has no more data&quot;;

status = usbPort.eod().send();
if ( status ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] - sent EOD&quot;;
} else {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] - FAILed to send EOD&quot;;
}
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_uKAnoMbIEeSvmLj5mtpd2g" event="_2QT44MXiEeSsD5C2f30z-g" port="_jacOAMYBEeSsD5C2f30z-g"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_GjQxwMeKEeSz1oN1Kl4Now" name="importNOK" guard="_V7QPcMeKEeSz1oN1Kl4Now" source="_9b6ywMeJEeSz1oN1Kl4Now" target="_bshqkMbGEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_V7QPcMeKEeSz1oN1Kl4Now" name="importNOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_V7QPcceKEeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( ! importOK );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_RsWXoO09EeStM4MpdkuAjQ" name="importNOK">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] could not import printer driver&quot; &lt;&lt; std::endl;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_IFuDAMeKEeSz1oN1Kl4Now" name="importOK" guard="_N0lDQMeKEeSz1oN1Kl4Now" source="_9b6ywMeJEeSz1oN1Kl4Now" target="_0xE8QO4aEeSJPsWo_Mnp3w">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_N0lDQMeKEeSz1oN1Kl4Now">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_N0lDQceKEeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( importOK );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_IaS9cO09EeStM4MpdkuAjQ" name="printDocument">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

status = usbPort.data(document).send();
if ( status ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] sent document to print&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] ERROR sending document to print&quot; &lt;&lt; std::endl;
}</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_nMG9IMeTEeSz1oN1Kl4Now" name="printPrintProgress" guard="_QccrsMf-EeSjr4LTYwlKOw" source="_h1RbUMeTEeSz1oN1Kl4Now" target="_mZ_S0MbGEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_QccrsMf-EeSjr4LTYwlKOw" name="Progress_LT_100">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_Qccrscf-EeSjr4LTYwlKOw">
                      <language>C++</language>
                      <body>return( progress &lt; 100);</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_79hWkMeTEeSz1oN1Kl4Now" name="printPrintProgress">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Printing... &quot; &lt;&lt; (int) progress &lt;&lt; &quot;%%&quot; &lt;&lt; std::endl;
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_4iR9AO4aEeSJPsWo_Mnp3w" guard="_TaFF4O4bEeSJPsWo_Mnp3w" source="_0xE8QO4aEeSJPsWo_Mnp3w" target="_bshqkMbGEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_TaFF4O4bEeSJPsWo_Mnp3w" name="statusNOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_TaFF4e4bEeSJPsWo_Mnp3w" name="statusNOK">
                      <language>C++</language>
                      <body>return( ! status );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_I2cMAPBgEeSy0dZlYL7EHw" name="couldNotPrint">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] could not print document&quot; &lt;&lt; std::endl;
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_5G7iMO4aEeSJPsWo_Mnp3w" guard="_NN3bQO4bEeSJPsWo_Mnp3w" source="_0xE8QO4aEeSJPsWo_Mnp3w" target="_mZ_S0MbGEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_NN3bQO4bEeSJPsWo_Mnp3w" name="statusOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_NN3bQe4bEeSJPsWo_Mnp3w" name="statusOK">
                      <language>C++</language>
                      <body>return( status );</body>
                    </specification>
                  </ownedRule>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_6wgK4MbEEeSvmLj5mtpd2g" name="waitForPrinter">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WFrQ0O4YEeSJPsWo_Mnp3w" name="waitingForPrinter">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] waiting for printer driver&quot; &lt;&lt; std::endl;
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_mZ_S0MbGEeSvmLj5mtpd2g" name="Printing"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_9b6ywMeJEeSz1oN1Kl4Now" name="importOK" kind="choice"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_h1RbUMeTEeSz1oN1Kl4Now" name="Choice1" kind="choice"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_0xE8QO4aEeSJPsWo_Mnp3w" name="printOK" kind="choice"/>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_RN478MbbEeSvmLj5mtpd2g" name="Saving">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WVfH4MbbEeSvmLj5mtpd2g" name="EntryPoint1" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_W86UQMbbEeSvmLj5mtpd2g" name="ExitPoint1" kind="exitPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_XUhjAMbbEeSvmLj5mtpd2g" name="ExitPoint2" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_apcfYBbHEeWa4sJtLVaM7A" name="saving_EN">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is {Saving}.&quot; &lt;&lt; std::endl;
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_WVcEksbbEeSvmLj5mtpd2g">
                <transition xmi:type="uml:Transition" xmi:id="_-HJfIMbbEeSvmLj5mtpd2g" name="getStorage" source="_WVfH4MbbEeSvmLj5mtpd2g" target="_fsiW0MbbEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Kn8eQMeBEeSz1oN1Kl4Now" name="requestStorageDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]&quot;;

if ( resourcePort.requestStorageDriver().send() ) {
	std::cout &lt;&lt; &quot; requested a storage driver&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot;FAILed to request a storage driver&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_-rGgwMbbEeSvmLj5mtpd2g" name="onSaveStatus" source="_iQYMkMbbEeSvmLj5mtpd2g" target="_u_tRwMeSEeSz1oN1Kl4Now">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_cysfEMbfEeSvmLj5mtpd2g" name="saveProgress">
                    <language>C++</language>
                    <body>progress = (int) *rtdata;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_JcYKoMbfEeSvmLj5mtpd2g" name="onStatus" event="_2QT44MXiEeSsD5C2f30z-g" port="_jacOAMYBEeSsD5C2f30z-g"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="__LtTcMbbEeSvmLj5mtpd2g" name="onResNotAvail" source="_fsiW0MbbEeSvmLj5mtpd2g" target="_W86UQMbbEeSvmLj5mtpd2g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_lmUFAMeIEeSz1oN1Kl4Now" name="noStorageAvailable">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[APPLICATION] storage driver not available&quot; &lt;&lt; std::endl;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_da2HkO4YEeSJPsWo_Mnp3w" name="onResNotAvail" event="_AFeJgMXKEeSsD5C2f30z-g" port="_JKtYAMQPEeSirL7ina4YrA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_AASLAMbcEeSvmLj5mtpd2g" name="saveCompleted" guard="_8nqKoMeREeSz1oN1Kl4Now" source="_u_tRwMeSEeSz1oN1Kl4Now" target="_XUhjAMbbEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_8nqKoMeREeSz1oN1Kl4Now" name="progress_GTE_100">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_8nqKoceREeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( progress >= 100 );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_xGvAAMbfEeSvmLj5mtpd2g" name="releaseStorage Driver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] has no more data&quot;;

status = usbPort.eod().send();
if ( status ) {
	std::cout &lt;&lt; &quot; - sent EOD&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; - FAILed to send EOD&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_BdvAcMbcEeSvmLj5mtpd2g" name="onStorageResource" source="_fsiW0MbbEeSvmLj5mtpd2g" target="_Ntc9AMeJEeSz1oN1Kl4Now">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mJe9IMeAEeSz1oN1Kl4Now" name="importStorageDriver">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

storageID = (UMLRTCapsuleId) *rtdata;

if ( storageID.isValid() ) {
	importOK = frame.import(storageID,deviceInterface );
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] importing a storage driver.&quot; &lt;&lt; std::endl;
} else {
	importOK = false;
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Invalid StorageDriver ID.&quot; &lt;&lt; std::endl;
}
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_kLLacMbdEeSvmLj5mtpd2g" name="onResourceID" event="_WOVBgMQeEeSirL7ina4YrA" port="_JKtYAMQPEeSirL7ina4YrA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_You-0MeJEeSz1oN1Kl4Now" name="importNOK" guard="_kX8X8MeJEeSz1oN1Kl4Now" source="_Ntc9AMeJEeSz1oN1Kl4Now" target="_W86UQMbbEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_kX8X8MeJEeSz1oN1Kl4Now" name="importNOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_kX8X8ceJEeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( ! importOK );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_k0IWQO08EeStM4MpdkuAjQ" name="CouldNotImport">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[APPLICATION] could not import storage driver&quot; &lt;&lt; std::endl;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_bzo0kMeJEeSz1oN1Kl4Now" name="importOK" guard="_rXnf0MeJEeSz1oN1Kl4Now" source="_Ntc9AMeJEeSz1oN1Kl4Now" target="_Rea8YO4ZEeSJPsWo_Mnp3w">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_rXnf0MeJEeSz1oN1Kl4Now" name="importOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_rXoG4MeJEeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( importOK );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_790dEMeJEeSz1oN1Kl4Now" name="saveDocument">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

status = usbPort.data(document).send();
if ( status ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] sends document to save&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] error sending document to save&quot; &lt;&lt; std::endl;
}</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_0H5TkMeSEeSz1oN1Kl4Now" name="printSaveProgress" guard="_OrRroMeTEeSz1oN1Kl4Now" source="_u_tRwMeSEeSz1oN1Kl4Now" target="_iQYMkMbbEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_OrRroMeTEeSz1oN1Kl4Now" name="progress_LT_100">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_OrRroceTEeSz1oN1Kl4Now">
                      <language>C++</language>
                      <body>return( progress &lt; 100 );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Coi5kMeTEeSz1oN1Kl4Now" name="printSaveProgress">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Saving...&quot; &lt;&lt; (int) progress &lt;&lt; &quot;%%&quot; &lt;&lt; std::endl;
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_Upvo4O4ZEeSJPsWo_Mnp3w" name="isOK" guard="_7uIqcO4ZEeSJPsWo_Mnp3w" source="_Rea8YO4ZEeSJPsWo_Mnp3w" target="_iQYMkMbbEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_7uIqcO4ZEeSJPsWo_Mnp3w" name="isOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_7uIqce4ZEeSJPsWo_Mnp3w" name="statusTrue">
                      <language>C++</language>
                      <body>return( status );</body>
                    </specification>
                  </ownedRule>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_VruqUO4ZEeSJPsWo_Mnp3w" name="isNOK" guard="_EXhiIO4aEeSJPsWo_Mnp3w" source="_Rea8YO4ZEeSJPsWo_Mnp3w" target="_W86UQMbbEeSvmLj5mtpd2g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_EXhiIO4aEeSJPsWo_Mnp3w" name="statusNOK">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_EXhiIe4aEeSJPsWo_Mnp3w" name="statusNOK">
                      <language>C++</language>
                      <body>return ( ! status );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZsBegPBfEeSy0dZlYL7EHw" name="couldNotSave">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] could not save document&quot; &lt;&lt; std::endl;
</body>
                  </effect>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_fsiW0MbbEeSvmLj5mtpd2g" name="WaitForStorage">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_JqErwO4YEeSJPsWo_Mnp3w" name="waitingForStorage">
                    <language>C++</language>
                    <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] waiting for storage driver&quot; &lt;&lt; std::endl;
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_iQYMkMbbEeSvmLj5mtpd2g" name="Saving"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_Ntc9AMeJEeSz1oN1Kl4Now" name="importOK" kind="choice"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_u_tRwMeSEeSz1oN1Kl4Now" name="Choice1" kind="choice"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_Rea8YO4ZEeSJPsWo_Mnp3w" name="saveOK" kind="choice"/>
              </region>
            </subvertex>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_IVP_8PBfEeSy0dZlYL7EHw" client="_9YrV0MOJEeSSS8SwKHucgQ" supplier="_e2WAMMQeEeSirL7ina4YrA"/>
      <packagedElement xmi:type="uml:Association" xmi:id="_rNRccAiBEeWmptSG6Ct2-w" visibility="protected" memberEnd="_rNdCoAiBEeWmptSG6Ct2-w _0JrmgMQUEeSirL7ina4YrA" navigableOwnedEnd="_0JrmgMQUEeSirL7ina4YrA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_rNZ_UAiBEeWmptSG6Ct2-w" source="org.eclipse.papyrus">
          <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_rNamYAiBEeWmptSG6Ct2-w" key="nature" value="UML_Nature"/>
        </eAnnotations>
        <ownedEnd xmi:type="uml:Property" xmi:id="_0JrmgMQUEeSirL7ina4YrA" name="applicationType" visibility="protected" type="_5luYcMQUEeSirL7ina4YrA" aggregation="composite" association="_rNRccAiBEeWmptSG6Ct2-w"/>
        <ownedEnd xmi:type="uml:Property" xmi:id="_rNdCoAiBEeWmptSG6Ct2-w" name="application" type="_N2fr8MOyEeSxS9_G15_gSg" association="_rNRccAiBEeWmptSG6Ct2-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Association" xmi:id="_ZtZPwAiCEeWmptSG6Ct2-w" visibility="protected" memberEnd="_Ztad4QiCEeWmptSG6Ct2-w _WvYkUMQXEeSirL7ina4YrA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_ZtZ20AiCEeWmptSG6Ct2-w" source="org.eclipse.papyrus">
          <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_ZtZ20QiCEeWmptSG6Ct2-w" key="nature" value="UML_Nature"/>
        </eAnnotations>
        <ownedEnd xmi:type="uml:Property" xmi:id="_Ztad4QiCEeWmptSG6Ct2-w" name="wordprocessorapp" type="_9YrV0MOJEeSSS8SwKHucgQ" association="_ZtZPwAiCEeWmptSG6Ct2-w"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_9LmtsMOKEeSSS8SwKHucgQ" name="Hardware">
      <packagedElement xmi:type="uml:Package" xmi:id="_0NJpIMODEeSSS8SwKHucgQ" name="USB">
        <packagedElement xmi:type="uml:Class" xmi:id="_ZUBdgIB6EeSeANT-DfY5oA" name="USBDeviceDriver" classifierBehavior="_TT09IIFgEeSuOriThrPJWQ" isActive="true">
          <ownedAttribute xmi:type="uml:Port" xmi:id="_ui7KkICCEeSeANT-DfY5oA" name="usbExtPort" visibility="public" type="_6tx6sIB-EeSeANT-DfY5oA" isOrdered="true" aggregation="composite" isConjugated="true">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_OtZUMMOxEeSxS9_G15_gSg" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_OtdloMOxEeSxS9_G15_gSg" value="1"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_WXpRoMOGEeSSS8SwKHucgQ" name="deviceClass" visibility="protected" isStatic="true" type="_bFD18IB9EeSeANT-DfY5oA" isReadOnly="true" aggregation="composite">
            <defaultValue xmi:type="uml:InstanceValue" xmi:id="_pE2XoMOGEeSSS8SwKHucgQ" type="_bFD18IB9EeSeANT-DfY5oA" instance="_flU8IIB9EeSeANT-DfY5oA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Port" xmi:id="_vXWH4MXgEeSsD5C2f30z-g" name="usbInPort" type="_6tx6sIB-EeSeANT-DfY5oA" isOrdered="true" aggregation="composite" isConjugated="true"/>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_QheE4MgaEeSjr4LTYwlKOw" name="busID" visibility="protected" aggregation="composite">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_TEJxwBEQEeWflIKGXXXMWw"/>
          </ownedAttribute>
          <ownedConnector xmi:type="uml:Connector" xmi:id="_GcZp4I--EeWMLsWj-jBDew" name="Connector1">
            <end xmi:type="uml:ConnectorEnd" xmi:id="_GcctMI--EeWMLsWj-jBDew" role="_ui7KkICCEeSeANT-DfY5oA"/>
            <end xmi:type="uml:ConnectorEnd" xmi:id="_GcdUQI--EeWMLsWj-jBDew" role="_vXWH4MXgEeSsD5C2f30z-g"/>
          </ownedConnector>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_TT09IIFgEeSuOriThrPJWQ" name="USBDeviceDriver_SM" isReentrant="false">
            <region xmi:type="uml:Region" xmi:id="_U3yDMIFgEeSuOriThrPJWQ" name="Region1">
              <transition xmi:type="uml:Transition" xmi:id="_kPbioIFgEeSuOriThrPJWQ" name="initialize" source="_YntRkIFgEeSuOriThrPJWQ" target="_aIsjMIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_1QfP4IFgEeSuOriThrPJWQ" name="initialize">
                  <language>C++</language>
                  <body>busID = 1; // This should really be provided as part of the driver creation/initialization

time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Initializing USB driver on bus &quot; &lt;&lt; busID &lt;&lt; std::endl;

</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_YrmYQMgbEeSjr4LTYwlKOw" name="onDeviceClass" source="_aIsjMIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_FOpI8MgeEeSjr4LTYwlKOw" name="sendBusID">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;.{onDeviceClass}] connected to external device&quot; ;

// if ( usbExtPort.setDeviceBusID(busID).send() ) {
// 	std::cout &lt;&lt; &quot; and sent bus ID to device&quot;;
// }   else {
// 	std::cout &lt;&lt; &quot; and failed to send BusID to device&quot;;
// }

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_UtQogMgdEeSjr4LTYwlKOw" name="usbextport-deviceClass" event="_JWO6UMW2EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_JnlCoMgfEeSjr4LTYwlKOw" name="on_usbInPort-data" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_By03cMggEeSjr4LTYwlKOw" name="forwardDataOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data out&quot;;

if ( ! usbExtPort.data((char*)*(void **)msg->getParam(0)).send() ) {
	std::cout &lt;&lt; &quot; and failed to forward data&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_vU7_0MgfEeSjr4LTYwlKOw" name="on_usbInPort-data" event="_sd1YQICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_C6FDMMdLEeSiG8QCXtAiEg" name="on_usbInPort-eod" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_9SFqgMdLEeSiG8QCXtAiEg" name="forwardEODOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_lnxKQMdLEeSiG8QCXtAiEg" name="on_usbInPort-eod" event="_sh4x0ICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_3ZpBsMdREeSiG8QCXtAiEg" name="on_usbInPort-ack" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Z3wigPBhEeSy0dZlYL7EHw" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt;&quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_7lWRkGLrEeWdXZOiB-_tgQ" name="on_usbInPort-ack" event="_E41HgICBEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_n5l-wMdSEeSiG8QCXtAiEg" name="on_usbExtPort-data" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_vI2hkPBhEeSy0dZlYL7EHw" name="forwardDataIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.data((char*)*(void **)msg->getParam(0)).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding data&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_s9X7kGLrEeWdXZOiB-_tgQ" name="on_usbExtPort-data" event="_sd1YQICAEeSeANT-DfY5oA" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_w2aIwMdSEeSiG8QCXtAiEg" name="on_usbExtPort-eod" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_6MhqYPBhEeSy0dZlYL7EHw" name="forwardEodIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_d3rHwGLrEeWdXZOiB-_tgQ" name="on_usbExtPort-eod" event="_sh4x0ICAEeSeANT-DfY5oA" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_Ao6_QMdTEeSiG8QCXtAiEg" name="on_usbExtPort-ack" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_A_yG4PBiEeSy0dZlYL7EHw" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_ZLtH4GLrEeWdXZOiB-_tgQ" name="on_usbExtPort-ack" event="_E41HgICBEeSeANT-DfY5oA" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_GqxM8MdTEeSiG8QCXtAiEg" name="onExtEject" visibility="public" source="_9aW6AIFgEeSuOriThrPJWQ" target="_aIsjMIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_QG9r8PBjEeSy0dZlYL7EHw" name="ExternalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] external device requested Eject&quot;;

if ( ! usbInPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_Pe3qYMdUEeSiG8QCXtAiEg" name="usbExtPort-Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_Pyu3AMdTEeSiG8QCXtAiEg" name="on_usbExtPort-deviceClass" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Nu1zcPBiEeSy0dZlYL7EHw" name="forwardDeviceClass">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding Device Class in&quot; &lt;&lt; std::endl;

//    if ( ! usbInPort.deviceClass( static_cast&lt;USBDeviceClasses> ((int) *rtdata) ).send() ) {
    if ( ! usbInPort.deviceClass( *((USBDeviceClasses*) msg->getParam( 0 )) ).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]failed to forward Device Class&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_P-ULQGLrEeWdXZOiB-_tgQ" name="on_usbExtPort-deviceClass" event="_JWO6UMW2EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_ufBsAPBiEeSy0dZlYL7EHw" name="onIntEject" source="_9aW6AIFgEeSuOriThrPJWQ" target="_aIsjMIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_VHrz0PBjEeSy0dZlYL7EHw" name="internalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] internal device requested Eject&quot;;

if ( ! usbExtPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot;;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_-RVHIPBiEeSy0dZlYL7EHw" name="usbInPort_Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_zs7v0Ba4EeWD0440ocvGbg" name="on_usbExtport-status" source="_9aW6AIFgEeSuOriThrPJWQ" target="_9aW6AIFgEeSuOriThrPJWQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_UDr0sBa5EeWD0440ocvGbg" name="fwdStatusIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding status in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.status(*rtdata).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding status&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_EBCQcBa5EeWD0440ocvGbg" name="on_usbExtPort-status" event="_2QT44MXiEeSsD5C2f30z-g" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_YntRkIFgEeSuOriThrPJWQ" name="Initial1"/>
              <subvertex xmi:type="uml:State" xmi:id="_aIsjMIFgEeSuOriThrPJWQ" name="Available">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_0XRXgA4LEeWZmqO69MGcNA" name="Available_EN">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is available&quot; &lt;&lt; std::endl;</body>
                </entry>
              </subvertex>
              <subvertex xmi:type="uml:State" xmi:id="_9aW6AIFgEeSuOriThrPJWQ" name="Connected"/>
            </region>
          </ownedBehavior>
        </packagedElement>
        <packagedElement xmi:type="uml:Class" xmi:id="_vk5ZsMOFEeSSS8SwKHucgQ" name="USBPrinterDriver" classifierBehavior="_V65iEBbGEeWa4sJtLVaM7A" isActive="true">
          <generalization xmi:type="uml:Generalization" xmi:id="_4Rk18MOFEeSSS8SwKHucgQ" general="_ZUBdgIB6EeSeANT-DfY5oA"/>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_7mBMwMOGEeSSS8SwKHucgQ" name="usbDevice" visibility="protected" isStatic="true" type="_bFD18IB9EeSeANT-DfY5oA" isReadOnly="true" aggregation="composite" redefinedProperty="_WXpRoMOGEeSSS8SwKHucgQ">
            <defaultValue xmi:type="uml:InstanceValue" xmi:id="_UOIyAMOHEeSSS8SwKHucgQ" type="_bFD18IB9EeSeANT-DfY5oA" instance="_qBD7MIB9EeSeANT-DfY5oA"/>
          </ownedAttribute>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_V65iEBbGEeWa4sJtLVaM7A" name="USBDeviceDriver_SM" redefinedClassifier="_TT09IIFgEeSuOriThrPJWQ" isReentrant="false" extendedStateMachine="_TT09IIFgEeSuOriThrPJWQ">
            <region xmi:type="uml:Region" xmi:id="_V8lkIBbGEeWa4sJtLVaM7A" name="Region1" extendedRegion="_U3yDMIFgEeSuOriThrPJWQ">
              <transition xmi:type="uml:Transition" xmi:id="_V9MoIBbGEeWa4sJtLVaM7A" name="initialize" redefinedTransition="_kPbioIFgEeSuOriThrPJWQ" source="_V8mLPBbGEeWa4sJtLVaM7A" target="_V88JcBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9MoIRbGEeWa4sJtLVaM7A" name="initialize">
                  <language>C++</language>
                  <body>busID = 1; // This should really be provided as part of the driver creation/initialization

time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Initializing USB driver on bus &quot; &lt;&lt; busID &lt;&lt; std::endl;

</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9QSgBbGEeWa4sJtLVaM7A" name="onDeviceClass" redefinedTransition="_YrmYQMgbEeSjr4LTYwlKOw" source="_V88JcBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9QSgRbGEeWa4sJtLVaM7A" name="sendBusID">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;.{onDeviceClass}] connected to external device&quot; ;

// if ( usbExtPort.setDeviceBusID(busID).send() ) {
// 	std::cout &lt;&lt; &quot; and sent bus ID to device&quot;;
// } else {
// 	std::cout &lt;&lt; &quot; and failed to send BusID to device&quot;;
// }

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9Q5kBbGEeWa4sJtLVaM7A" name="usbextport-deviceClass" event="_JWO6UMW2EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9RgoBbGEeWa4sJtLVaM7A" name="on_usbInPort-data" redefinedTransition="_JnlCoMgfEeSjr4LTYwlKOw" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9RgoRbGEeWa4sJtLVaM7A" name="forwardDataOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data out&quot;;

if ( ! usbExtPort.data((char*)*(void **)msg->getParam(0)).send() ) {
	std::cout &lt;&lt; &quot; and failed to forward data&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9RgohbGEeWa4sJtLVaM7A" name="usbInPort-data" event="_sd1YQICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9SuwBbGEeWa4sJtLVaM7A" name="on_usbInPort-eod" redefinedTransition="_C6FDMMdLEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9SuwRbGEeWa4sJtLVaM7A" name="forwardEODOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9SuwhbGEeWa4sJtLVaM7A" name="onEOD" event="_sh4x0ICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9T84BbGEeWa4sJtLVaM7A" name="on_usbInPort-ack" redefinedTransition="_3ZpBsMdREeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9T84RbGEeWa4sJtLVaM7A" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt;&quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9VLABbGEeWa4sJtLVaM7A" name="on_usbExtPort-data" redefinedTransition="_n5l-wMdSEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9VLARbGEeWa4sJtLVaM7A" name="forwardDataIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.data( (char*) * (void **) msg->getParam(0) ).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding data&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9WZIBbGEeWa4sJtLVaM7A" name="on_usbExtPort-eod" redefinedTransition="_w2aIwMdSEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9WZIRbGEeWa4sJtLVaM7A" name="forwardEodIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9XnQBbGEeWa4sJtLVaM7A" name="on_usbExtPort-ack" redefinedTransition="_Ao6_QMdTEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9XnQRbGEeWa4sJtLVaM7A" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9YOUBbGEeWa4sJtLVaM7A" name="onExtEject" visibility="public" redefinedTransition="_GqxM8MdTEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V88JcBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9YOURbGEeWa4sJtLVaM7A" name="ExternalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] external device requested Eject&quot;;

if ( ! usbInPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9YOUhbGEeWa4sJtLVaM7A" name="usbExtPort-Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9ZccBbGEeWa4sJtLVaM7A" name="on_usbExtPort-deviceClass" redefinedTransition="_Pyu3AMdTEeSiG8QCXtAiEg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9ZccRbGEeWa4sJtLVaM7A" name="forwardDeviceClass">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding Device Class in&quot; &lt;&lt; std::endl;

//    if ( ! usbInPort.deviceClass( static_cast&lt;USBDeviceClasses> ((int) *rtdata) ).send() ) {
    if ( ! usbInPort.deviceClass( *((USBDeviceClasses*) msg->getParam( 0 )) ).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]failed to forward Device Class&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9aDgBbGEeWa4sJtLVaM7A" name="onIntEject" redefinedTransition="_ufBsAPBiEeSy0dZlYL7EHw" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V88JcBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9aqkBbGEeWa4sJtLVaM7A" name="internalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] internal device requested Eject&quot;;

if ( ! usbExtPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot;;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9aqkRbGEeWa4sJtLVaM7A" name="usbInPort_Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V9bRoBbGEeWa4sJtLVaM7A" name="on_usbExtport-status" redefinedTransition="_zs7v0Ba4EeWD0440ocvGbg" source="_V8_MwBbGEeWa4sJtLVaM7A" target="_V8_MwBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V9bRoRbGEeWa4sJtLVaM7A" name="fwdStatusIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding status in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.status(*rtdata).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding status&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V9bRohbGEeWa4sJtLVaM7A" name="on_ustextPort-status" event="_2QT44MXiEeSsD5C2f30z-g" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_V8mLPBbGEeWa4sJtLVaM7A" name="Initial1"/>
              <subvertex xmi:type="uml:State" xmi:id="_V88JcBbGEeWa4sJtLVaM7A" name="Available" redefinedState="_aIsjMIFgEeSuOriThrPJWQ">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_V88JcRbGEeWa4sJtLVaM7A" name="Available_EN">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is available&quot; &lt;&lt; std::endl;</body>
                </entry>
              </subvertex>
              <subvertex xmi:type="uml:State" xmi:id="_V8_MwBbGEeWa4sJtLVaM7A" name="Connected" redefinedState="_9aW6AIFgEeSuOriThrPJWQ"/>
            </region>
          </ownedBehavior>
        </packagedElement>
        <packagedElement xmi:type="uml:Class" xmi:id="_z6QQYMOFEeSSS8SwKHucgQ" name="USBStorageDriver" classifierBehavior="_V9oF8BbGEeWa4sJtLVaM7A" isActive="true">
          <generalization xmi:type="uml:Generalization" xmi:id="_47ZPAMOFEeSSS8SwKHucgQ" general="_ZUBdgIB6EeSeANT-DfY5oA"/>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_FqE2MMOIEeSSS8SwKHucgQ" name="deviceClass" visibility="protected" isStatic="true" type="_bFD18IB9EeSeANT-DfY5oA" isReadOnly="true" aggregation="composite" redefinedProperty="_WXpRoMOGEeSSS8SwKHucgQ">
            <defaultValue xmi:type="uml:InstanceValue" xmi:id="_WYxoIMOIEeSSS8SwKHucgQ" type="_bFD18IB9EeSeANT-DfY5oA" instance="_u6g9cIB9EeSeANT-DfY5oA"/>
          </ownedAttribute>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_V9oF8BbGEeWa4sJtLVaM7A" name="USBDeviceDriver_SM" redefinedClassifier="_TT09IIFgEeSuOriThrPJWQ" isReentrant="false" extendedStateMachine="_TT09IIFgEeSuOriThrPJWQ">
            <region xmi:type="uml:Region" xmi:id="_V-CVoBbGEeWa4sJtLVaM7A" name="Region1" extendedRegion="_U3yDMIFgEeSuOriThrPJWQ">
              <transition xmi:type="uml:Transition" xmi:id="_V-fBkBbGEeWa4sJtLVaM7A" name="initialize" redefinedTransition="_kPbioIFgEeSuOriThrPJWQ" source="_V-C8shbGEeWa4sJtLVaM7A" target="_V-PxABbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-fBkRbGEeWa4sJtLVaM7A" name="initialize">
                  <language>C++</language>
                  <body>busID = 1; // This should really be provided as part of the driver creation/initialization

time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Initializing USB driver on bus &quot; &lt;&lt; busID &lt;&lt; std::endl;

</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-gPsBbGEeWa4sJtLVaM7A" name="onDeviceClass" redefinedTransition="_YrmYQMgbEeSjr4LTYwlKOw" source="_V-PxABbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-gPsRbGEeWa4sJtLVaM7A" name="sendBusID">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;.{onDeviceClass}] connected to external device&quot; ;

// if ( usbExtPort.setDeviceBusID(busID).send() ) {
// 	std::cout &lt;&lt; &quot; and sent bus ID to device&quot;;
// } else {
// 	std::cout &lt;&lt; &quot; and failed to send BusID to device&quot;;
// }

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-gPshbGEeWa4sJtLVaM7A" name="usbextport-deviceClass" event="_JWO6UMW2EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-g2wBbGEeWa4sJtLVaM7A" name="on_usbInPort-data" redefinedTransition="_JnlCoMgfEeSjr4LTYwlKOw" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-g2wRbGEeWa4sJtLVaM7A" name="forwardDataOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data out&quot;;

if ( ! usbExtPort.data((char*)*(void **)msg->getParam(0)).send() ) {
	std::cout &lt;&lt; &quot; and failed to forward data&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-g2whbGEeWa4sJtLVaM7A" name="usbInPort-data" event="_sd1YQICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-iE4BbGEeWa4sJtLVaM7A" name="on_usbInPort-eod" redefinedTransition="_C6FDMMdLEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-iE4RbGEeWa4sJtLVaM7A" name="forwardEODOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-iE4hbGEeWa4sJtLVaM7A" name="onEOD" event="_sh4x0ICAEeSeANT-DfY5oA" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-jTABbGEeWa4sJtLVaM7A" name="on_usbInPort-ack" redefinedTransition="_3ZpBsMdREeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-jTARbGEeWa4sJtLVaM7A" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt;&quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK out&quot; &lt;&lt; std::endl;

if ( ! usbExtPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-khIBbGEeWa4sJtLVaM7A" name="on_usbExtPort-data" redefinedTransition="_n5l-wMdSEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-khIRbGEeWa4sJtLVaM7A" name="forwardDataIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding data in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.data((char*)*(void **)msg->getParam(0)).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding data&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-lvQBbGEeWa4sJtLVaM7A" name="on_usbExtPort-eod" redefinedTransition="_w2aIwMdSEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-lvQRbGEeWa4sJtLVaM7A" name="forwardEodIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding EOD in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.eod().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding EOD&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-m9YBbGEeWa4sJtLVaM7A" name="on_usbExtPort-ack" redefinedTransition="_Ao6_QMdTEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-m9YRbGEeWa4sJtLVaM7A" name="forwardAckOut">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding ACK in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.ack().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding ACK&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-oLgBbGEeWa4sJtLVaM7A" name="onExtEject" visibility="public" redefinedTransition="_GqxM8MdTEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-PxABbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-oLgRbGEeWa4sJtLVaM7A" name="ExternalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] external device requested Eject&quot;;

if ( ! usbInPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot; &lt;&lt; std::endl;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-oLghbGEeWa4sJtLVaM7A" name="usbExtPort-Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-pZoBbGEeWa4sJtLVaM7A" name="on_usbExtPort-deviceClass" redefinedTransition="_Pyu3AMdTEeSiG8QCXtAiEg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-pZoRbGEeWa4sJtLVaM7A" name="forwardDeviceClass">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding Device Class in&quot; &lt;&lt; std::endl;

//    if ( ! usbInPort.deviceClass( static_cast&lt;USBDeviceClasses> ((int) *rtdata) ).send() ) {
    if ( ! usbInPort.deviceClass( *((USBDeviceClasses*) msg->getParam( 0 )) ).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forward Device Class&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-qnwBbGEeWa4sJtLVaM7A" name="onIntEject" redefinedTransition="_ufBsAPBiEeSy0dZlYL7EHw" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-PxABbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-qnwRbGEeWa4sJtLVaM7A" name="internalDeviceEject">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] internal device requested Eject&quot;;

if ( ! usbExtPort.Eject().send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] and failed to forward Eject&quot;;
}

std::cout &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-qnwhbGEeWa4sJtLVaM7A" name="usbInPort_Eject" event="__0FOoMW1EeSd16LgMAJOmw" port="_vXWH4MXgEeSsD5C2f30z-g"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_V-r14BbGEeWa4sJtLVaM7A" name="on_usbExtport-status" redefinedTransition="_zs7v0Ba4EeWD0440ocvGbg" source="_V-RmMBbGEeWa4sJtLVaM7A" target="_V-RmMBbGEeWa4sJtLVaM7A">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_V-r14RbGEeWa4sJtLVaM7A" name="fwdStatusIn">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] forwarding status in&quot; &lt;&lt; std::endl;

if ( ! usbInPort.status(*rtdata).send() ) {
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] failed to forwarding status&quot; &lt;&lt; std::endl;
}
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_V-r14hbGEeWa4sJtLVaM7A" name="on_ustextPort-status" event="_2QT44MXiEeSsD5C2f30z-g" port="_ui7KkICCEeSeANT-DfY5oA"/>
              </transition>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_V-C8shbGEeWa4sJtLVaM7A" name="Initial1"/>
              <subvertex xmi:type="uml:State" xmi:id="_V-PxABbGEeWa4sJtLVaM7A" name="Available" redefinedState="_aIsjMIFgEeSuOriThrPJWQ">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_V-PxARbGEeWa4sJtLVaM7A" name="Available_EN">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is available&quot; &lt;&lt; std::endl;</body>
                </entry>
              </subvertex>
              <subvertex xmi:type="uml:State" xmi:id="_V-RmMBbGEeWa4sJtLVaM7A" name="Connected" redefinedState="_9aW6AIFgEeSuOriThrPJWQ"/>
            </region>
          </ownedBehavior>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_eCGWcMQ3EeSsW5rXQX5TZg" client="_ZUBdgIB6EeSeANT-DfY5oA" supplier="_bFD18IB9EeSeANT-DfY5oA"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_Ik9B0MXLEeSsD5C2f30z-g" name="ExternalDevices">
        <packagedElement xmi:type="uml:Class" xmi:id="_CperoMOLEeSSS8SwKHucgQ" name="LocalPrinter" visibility="public" classifierBehavior="_Qm-r0MOMEeSSS8SwKHucgQ" isActive="true">
          <ownedAttribute xmi:type="uml:Port" xmi:id="_SSMs8MOLEeSSS8SwKHucgQ" name="usbPort" type="_6tx6sIB-EeSeANT-DfY5oA" isOrdered="true" aggregation="composite" isBehavior="true"/>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_ra0FQMONEeSSS8SwKHucgQ" name="usbClass" visibility="protected" type="_bFD18IB9EeSeANT-DfY5oA" aggregation="composite">
            <defaultValue xmi:type="uml:InstanceValue" xmi:id="_2TmzwMONEeSSS8SwKHucgQ" type="_bFD18IB9EeSeANT-DfY5oA" instance="_qBD7MIB9EeSeANT-DfY5oA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_a1y-UMOOEeSSS8SwKHucgQ" name="connectionStatus" visibility="protected" aggregation="composite">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Port" xmi:id="_hwfLcO0CEeSVocSGS756bA" name="log" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
            <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_x2khYO0GEeSzlZWHZcnPXA" name="printingData" visibility="protected">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
            <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_8iHeEO0GEeSzlZWHZcnPXA"/>
          </ownedAttribute>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_Qm-r0MOMEeSSS8SwKHucgQ" name="LocalPrinter_SM" isReentrant="false">
            <region xmi:type="uml:Region" xmi:id="_Shge0MOMEeSSS8SwKHucgQ" name="Region1">
              <transition xmi:type="uml:Transition" xmi:id="_wVMKAMOMEeSSS8SwKHucgQ" name="initialize" source="_oTeWUMOMEeSSS8SwKHucgQ" target="_RN0-gMOOEeSSS8SwKHucgQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="__DwQMMOMEeSSS8SwKHucgQ" name="Connect_Printer">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing.&quot; &lt;&lt; std::endl;

connectionStatus = usbPort.deviceClass(usbClass).send();
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_WwbrcMOOEeSSS8SwKHucgQ" name="MsgSendFail" guard="_6xVG0MOOEeSSS8SwKHucgQ" source="_RN0-gMOOEeSSS8SwKHucgQ" target="_TRQO0MOOEeSSS8SwKHucgQ">
                <ownedRule xmi:type="uml:Constraint" xmi:id="_6xVG0MOOEeSSS8SwKHucgQ" name="ifNotConnected">
                  <specification xmi:type="uml:OpaqueExpression" xmi:id="_6xVG0cOOEeSSS8SwKHucgQ">
                    <language>C++</language>
                    <body>return(! connectionStatus);</body>
                  </specification>
                </ownedRule>
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rVg5EMOOEeSSS8SwKHucgQ" name="PrinterConnectionFailed">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Error sending device class to hub : connection failed {&quot; &lt;&lt; connectionStatus &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_7_MBEMOOEeSSS8SwKHucgQ" name="MessageSent" guard="_BNpC8MOPEeSSS8SwKHucgQ" source="_RN0-gMOOEeSSS8SwKHucgQ" target="_tkuNgMOMEeSSS8SwKHucgQ">
                <ownedRule xmi:type="uml:Constraint" xmi:id="_BNpC8MOPEeSSS8SwKHucgQ" name="ifConnected">
                  <specification xmi:type="uml:OpaqueExpression" xmi:id="_BNpC8cOPEeSSS8SwKHucgQ">
                    <language>C++</language>
                    <body>return(connectionStatus);</body>
                  </specification>
                </ownedRule>
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rPoUsMOoEeSy9Z1Kd1VJnQ" name="DeviceClassSent">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] sent its device class to the hub and is now {Connected}.&quot; &lt;&lt; std::endl;
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_fyXCIMOSEeSSS8SwKHucgQ" name="onData" source="_tkuNgMOMEeSSS8SwKHucgQ" target="_tkuNgMOMEeSSS8SwKHucgQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mQV8wMOTEeSSS8SwKHucgQ" name="PrintData" isReentrant="false">
                  <language>C++</language>
                  <body>/**
 * Only show logging start on 1st dataset received
 */
if ( ! printingData ) {
	time_t currentTime;
	struct tm *localTime;
	time( &amp;currentTime );
	localTime = localtime( &amp;currentTime );
	std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Printing Start ==========&quot; &lt;&lt; std::endl;

	printingData = true;
}

std::cout &lt;&lt; (char *) umlrtparam_data;

usbPort.status(100).send();
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_AszC4MOTEeSSS8SwKHucgQ" event="_sd1YQICAEeSeANT-DfY5oA" port="_SSMs8MOLEeSSS8SwKHucgQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_nsX14MOTEeSSS8SwKHucgQ" name="onEOD" source="_tkuNgMOMEeSSS8SwKHucgQ" target="_tkuNgMOMEeSSS8SwKHucgQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Li3_IMOUEeSSS8SwKHucgQ" name="PrintingEnd">
                  <language>C++</language>
                  <body>std::cout &lt;&lt; std::endl;

time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Printing Ended ==========&quot; &lt;&lt; std::endl;

printingData = false;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_BnKj8MOUEeSSS8SwKHucgQ" name="onEOD" event="_sh4x0ICAEeSeANT-DfY5oA" port="_SSMs8MOLEeSSS8SwKHucgQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_a7hUYMOlEeSy9Z1Kd1VJnQ" name="onEject" visibility="package" source="_tkuNgMOMEeSSS8SwKHucgQ" target="_TRQO0MOOEeSSS8SwKHucgQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_13uUwMOoEeSy9Z1Kd1VJnQ" name="EjectPrinter">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] ejected!&quot; &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_JWF5UMOmEeSy9Z1Kd1VJnQ" name="onEject" event="__0FOoMW1EeSd16LgMAJOmw" port="_SSMs8MOLEeSSS8SwKHucgQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_RadG8AuoEeWCGuiso4e4-g" name="onConnect" source="_TRQO0MOOEeSSS8SwKHucgQ" target="_tkuNgMOMEeSSS8SwKHucgQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_DS0ocAupEeWCGuiso4e4-g" name="connectingPrinter">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] received a connection request and is now in {Connected} state.&quot; &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_j7ojIAuoEeWCGuiso4e4-g" name="onConnect" event="_CudmMMXkEeSsD5C2f30z-g" port="_SSMs8MOLEeSSS8SwKHucgQ"/>
              </transition>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_oTeWUMOMEeSSS8SwKHucgQ" name="Initial1"/>
              <subvertex xmi:type="uml:State" xmi:id="_tkuNgMOMEeSSS8SwKHucgQ" name="Connected"/>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_RN0-gMOOEeSSS8SwKHucgQ" name="Connected?" kind="choice"/>
              <subvertex xmi:type="uml:State" xmi:id="_TRQO0MOOEeSSS8SwKHucgQ" name="Disconnected">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_0AZmkO0EEeST5KnPUdkGIg" name="Disconnected">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in {Disconnected} state.&quot; &lt;&lt; std::endl;
</body>
                </entry>
              </subvertex>
            </region>
          </ownedBehavior>
        </packagedElement>
        <packagedElement xmi:type="uml:Class" xmi:id="_FTGZQMOLEeSSS8SwKHucgQ" name="ExtMassStorage" classifierBehavior="_cv6NsMOmEeSy9Z1Kd1VJnQ" isActive="true">
          <ownedAttribute xmi:type="uml:Port" xmi:id="_q4ZLUMOmEeSy9Z1Kd1VJnQ" name="usbPort" visibility="public" type="_6tx6sIB-EeSeANT-DfY5oA" isOrdered="true" aggregation="composite" isBehavior="true"/>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_d692IMOnEeSy9Z1Kd1VJnQ" name="usbClass" visibility="protected" type="_bFD18IB9EeSeANT-DfY5oA" aggregation="composite">
            <defaultValue xmi:type="uml:InstanceValue" xmi:id="_d692IcOnEeSy9Z1Kd1VJnQ" type="_bFD18IB9EeSeANT-DfY5oA" instance="_u6g9cIB9EeSeANT-DfY5oA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_iKKlAMOoEeSy9Z1Kd1VJnQ" name="connectionStatus" visibility="protected" aggregation="composite">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Port" xmi:id="_DzjO4O0IEeSzlZWHZcnPXA" name="log" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
            <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_e9HAsO0JEeSzlZWHZcnPXA" name="savingData" visibility="protected">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
            <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_jlVwEO0JEeSzlZWHZcnPXA"/>
          </ownedAttribute>
          <ownedAttribute xmi:type="uml:Property" xmi:id="_cLxEMBa7EeWD0440ocvGbg" name="lineCount" visibility="protected" aggregation="composite">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_8heigBydEduyofBvg4RL2w"/>
          </ownedAttribute>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_cv6NsMOmEeSy9Z1Kd1VJnQ" name="ExtMassStorage_SM" isReentrant="false">
            <region xmi:type="uml:Region" xmi:id="_d298YMOmEeSy9Z1Kd1VJnQ" name="Region1">
              <transition xmi:type="uml:Transition" xmi:id="_YS9EwMOnEeSy9Z1Kd1VJnQ" name="initialize" source="_jTAHQMOmEeSy9Z1Kd1VJnQ" target="_OIT1sMOnEeSy9Z1Kd1VJnQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_aJ3GkMOoEeSy9Z1Kd1VJnQ" name="Initialize">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] initializing.&quot; &lt;&lt; std::endl;

connectionStatus = usbPort.deviceClass(usbClass).send();
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_Y9i54MOnEeSy9Z1Kd1VJnQ" name="Connected" guard="_RACl4MOpEeSy9Z1Kd1VJnQ" source="_OIT1sMOnEeSy9Z1Kd1VJnQ" target="_PG3vsMOnEeSy9Z1Kd1VJnQ">
                <ownedRule xmi:type="uml:Constraint" xmi:id="_RACl4MOpEeSy9Z1Kd1VJnQ" name="ifMsgSent">
                  <specification xmi:type="uml:OpaqueExpression" xmi:id="_RACl4cOpEeSy9Z1Kd1VJnQ" name="Connected">
                    <language>C++</language>
                    <body>return(connectionStatus);</body>
                  </specification>
                </ownedRule>
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_e6gVoMOpEeSy9Z1Kd1VJnQ" name="deviceClassSent">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] sent its device class to the hub and is now in {Connected} state.&quot; &lt;&lt; std::endl;
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_ZiPiYMOnEeSy9Z1Kd1VJnQ" name="Connect Failed" guard="_nXcFsMOpEeSy9Z1Kd1VJnQ" source="_OIT1sMOnEeSy9Z1Kd1VJnQ" target="_Pm2QQMOnEeSy9Z1Kd1VJnQ">
                <ownedRule xmi:type="uml:Constraint" xmi:id="_nXcFsMOpEeSy9Z1Kd1VJnQ" name="ifSendFailed">
                  <specification xmi:type="uml:OpaqueExpression" xmi:id="_nXcFscOpEeSy9Z1Kd1VJnQ" name="Connect Fail">
                    <language>C++</language>
                    <body>return( ! connectionStatus );</body>
                  </specification>
                </ownedRule>
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_zAwSMMOpEeSy9Z1Kd1VJnQ" name="logFailedConnection">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] ERROR sending device class : Connection failed! {&quot; &lt;&lt;  connectionStatus &lt;&lt;  &quot;}.&quot;;
</body>
                </effect>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_aGZYUMOnEeSy9Z1Kd1VJnQ" name="Eject" source="_PG3vsMOnEeSy9Z1Kd1VJnQ" target="_Pm2QQMOnEeSy9Z1Kd1VJnQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_teR2MMOrEeSy9Z1Kd1VJnQ" name="DeviceEjected">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] ejected&quot; &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_KZlkYMOrEeSy9Z1Kd1VJnQ" event="__0FOoMW1EeSd16LgMAJOmw" port="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_zQlMAMOrEeSy9Z1Kd1VJnQ" name="onData" source="_PG3vsMOnEeSy9Z1Kd1VJnQ" target="_PG3vsMOnEeSy9Z1Kd1VJnQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_4xXMoMOuEeSxS9_G15_gSg" name="SavingData">
                  <language>C++</language>
                  <body>/**
 * Only show logging start on 1st dataset received
 */

time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );

if ( ! savingData ) {
	std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] starts saving ==========&quot; &lt;&lt; std::endl;
	savingData = true;
	lineCount = 0;
}

/**
 * Now print the data
 */
//std::cout &lt;&lt; (char *) *rtdata; // Still need debugging of data retrieval

std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[ Output #&quot; &lt;&lt; std::setw(4) &lt;&lt; ++lineCount &lt;&lt; &quot;] &quot; &lt;&lt; &quot;Aenean lacinia bibendum nulla sed consectetur.&quot; &lt;&lt; std::endl;

std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;
	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]&quot;;

if ( usbPort.status(100).send() ) {
	std::cout &lt;&lt; &quot;sent status = &quot; &lt;&lt; 100 &lt;&lt; &quot;%&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot;ERROR sending status!&quot; &lt;&lt; std::endl;
}

</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_T9MMIMOsEeSy9Z1Kd1VJnQ" name="onData" event="_sd1YQICAEeSeANT-DfY5oA" port="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_7hNeEMOuEeSxS9_G15_gSg" name="onEOD" source="_PG3vsMOnEeSy9Z1Kd1VJnQ" target="_PG3vsMOnEeSy9Z1Kd1VJnQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Qk3eEMOvEeSxS9_G15_gSg" name="DoneSaving">
                  <language>C++</language>
                  <body>std::cout &lt;&lt; std::endl;&#xD;
&#xD;
time_t currentTime;&#xD;
struct tm *localTime;&#xD;
time( &amp;currentTime );&#xD;
localTime = localtime( &amp;currentTime );&#xD;
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;&#xD;
&#xD;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] Saving Ended =====&quot; &lt;&lt; std::endl;&#xD;
&#xD;
savingData = false;&#xD;
&#xD;
exit(0); </body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_LiphYMOvEeSxS9_G15_gSg" event="_sh4x0ICAEeSeANT-DfY5oA" port="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
              </transition>
              <transition xmi:type="uml:Transition" xmi:id="_F60I8AuqEeWCGuiso4e4-g" name="onConnect" source="_Pm2QQMOnEeSy9Z1Kd1VJnQ" target="_PG3vsMOnEeSy9Z1Kd1VJnQ">
                <effect xmi:type="uml:OpaqueBehavior" xmi:id="_wOAo0AuqEeWCGuiso4e4-g" name="onConnect">
                  <language>C++</language>
                  <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] received connection request and is now in {Connected} state.&quot; &lt;&lt; std::endl;
</body>
                </effect>
                <trigger xmi:type="uml:Trigger" xmi:id="_pFa1gAuqEeWCGuiso4e4-g" name="onConnect" event="_CudmMMXkEeSsD5C2f30z-g" port="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
              </transition>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_jTAHQMOmEeSy9Z1Kd1VJnQ" name="Initial1"/>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_OIT1sMOnEeSy9Z1Kd1VJnQ" name="connected?" kind="choice"/>
              <subvertex xmi:type="uml:State" xmi:id="_PG3vsMOnEeSy9Z1Kd1VJnQ" name="Connected"/>
              <subvertex xmi:type="uml:State" xmi:id="_Pm2QQMOnEeSy9Z1Kd1VJnQ" name="Disconnected">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_0yU18O0IEeSzlZWHZcnPXA" name="StorageDisconnected">
                  <language>C++</language>
                  <body>std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is in {Disconnected} state.&quot; &lt;&lt; std::endl;
</body>
                </entry>
              </subvertex>
            </region>
          </ownedBehavior>
        </packagedElement>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_pfCSoMQdEeSirL7ina4YrA" name="Resource">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_sSppwMQdEeSirL7ina4YrA" name="Resource"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_sSsGAMQdEeSirL7ina4YrA" name="Resource">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_qNHGYA8YEeWl7ddVi7dGGQ" name="requestPrinterDriver"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_vbZJIA8YEeWl7ddVi7dGGQ" name="requestStorageDriver"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Realization" xmi:id="_sSw-gMQdEeSirL7ina4YrA" name="ProtocolRealizesIncomingInterface" client="_sSppwMQdEeSirL7ina4YrA" supplier="_sSsGAMQdEeSirL7ina4YrA"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_sSxlkMQdEeSirL7ina4YrA" name="Resource~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WOQwEMQeEeSirL7ina4YrA" name="resourceID">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WOQwEcQeEeSirL7ina4YrA" name="resourceID">
              <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_GfwZUICSEeSeANT-DfY5oA"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_AFVmoMXKEeSsD5C2f30z-g" name="resNotAvail"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_bqDV0O4MEeSAlbC0LA6o5Q" name="resMgrRunning"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_sS0o4MQdEeSirL7ina4YrA" name="ProtocolUsesOutgoingInterface" client="_sSppwMQdEeSirL7ina4YrA" supplier="_sSxlkMQdEeSirL7ina4YrA"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_sS1P8MQdEeSirL7ina4YrA" name="ResourceIo"/>
        <packagedElement xmi:type="uml:Realization" xmi:id="_sS4TQMQdEeSirL7ina4YrA" name="ProtocolRealizesSymInterface" client="_sSppwMQdEeSirL7ina4YrA" supplier="_sS1P8MQdEeSirL7ina4YrA"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_sS46UMQdEeSirL7ina4YrA" name="ProtocolUsesSymInterface" client="_sSppwMQdEeSirL7ina4YrA" supplier="_sS1P8MQdEeSirL7ina4YrA"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_sS5hYMQdEeSirL7ina4YrA" name="*"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WOVBgMQeEeSirL7ina4YrA" name="resourceID" operation="_WOQwEMQeEeSirL7ina4YrA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_AFeJgMXKEeSsD5C2f30z-g" name="resNotAvail" operation="_AFVmoMXKEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_zJOOoO4PEeSJPsWo_Mnp3w" name="resMgrRunning" operation="_bqDV0O4MEeSAlbC0LA6o5Q"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_qNNNAA8YEeWl7ddVi7dGGQ" name="requestPrinterDriver" operation="_qNHGYA8YEeWl7ddVi7dGGQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_vbaXQA8YEeWl7ddVi7dGGQ" name="requestStorageDriver" operation="_vbZJIA8YEeWl7ddVi7dGGQ"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_xrA4MMOyEeSxS9_G15_gSg" name="Protocols">
      <packagedElement xmi:type="uml:Package" xmi:id="_TL3RUMO2EeSxS9_G15_gSg" name="AppControl">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_vOIpQMO2EeSxS9_G15_gSg" name="AppControl"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_vOLFgMO2EeSxS9_G15_gSg" name="AppControl">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_tb5aIMO3EeSxS9_G15_gSg" name="createDocument">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_U6r-4BadEeWD0440ocvGbg" name="fileName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_5lVhgBydEduyofBvg4RL2w"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_tb5aIcO3EeSxS9_G15_gSg" name="data">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_8I6RgBydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_0zpDwMO3EeSxS9_G15_gSg" name="printDocument"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_93x9wMO3EeSxS9_G15_gSg" name="saveDocument"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_efUQoMO4EeSxS9_G15_gSg" name="addToDoc"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_eHBBABacEeWD0440ocvGbg" name="openDocument">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_nENlgBacEeWD0440ocvGbg" name="fileName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_5lVhgBydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_D5z30BadEeWD0440ocvGbg" name="closeDocument"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Realization" xmi:id="_vONhwMO2EeSxS9_G15_gSg" name="ProtocolRealizesIncomingInterface" client="_vOIpQMO2EeSxS9_G15_gSg" supplier="_vOLFgMO2EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_vOOI0MO2EeSxS9_G15_gSg" name="AppControl~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_FlWGYMO4EeSxS9_G15_gSg" name="docID">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_FlWGYcO4EeSxS9_G15_gSg" name="docID">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_N6dfMMXREeSsD5C2f30z-g" name="error"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_vOQlEMO2EeSxS9_G15_gSg" name="ProtocolUsesOutgoingInterface" client="_vOIpQMO2EeSxS9_G15_gSg" supplier="_vOOI0MO2EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_vORMIMO2EeSxS9_G15_gSg" name="AppControlIo"/>
        <packagedElement xmi:type="uml:Realization" xmi:id="_vOToYMO2EeSxS9_G15_gSg" name="ProtocolRealizesSymInterface" client="_vOIpQMO2EeSxS9_G15_gSg" supplier="_vORMIMO2EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_vOUPcMO2EeSxS9_G15_gSg" name="ProtocolUsesSymInterface" client="_vOIpQMO2EeSxS9_G15_gSg" supplier="_vORMIMO2EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_vOU2gMO2EeSxS9_G15_gSg" name="*"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_tb9rkMO3EeSxS9_G15_gSg" name="createDocument" operation="_tb5aIMO3EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_0zt8QMO3EeSxS9_G15_gSg" name="printDocument" operation="_0zpDwMO3EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_931oIMO3EeSxS9_G15_gSg" name="saveDocument" operation="_93x9wMO3EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_Flbl8MO4EeSxS9_G15_gSg" name="docID" operation="_FlWGYMO4EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_efZJIMO4EeSxS9_G15_gSg" name="addToDoc" operation="_efUQoMO4EeSxS9_G15_gSg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_N6f7cMXREeSsD5C2f30z-g" name="error" operation="_N6dfMMXREeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_eHEEUBacEeWD0440ocvGbg" name="openDocument" operation="_eHBBABacEeWD0440ocvGbg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_D51F8BadEeWD0440ocvGbg" name="closeDocument" operation="_D5z30BadEeWD0440ocvGbg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_vn-D4IB-EeSeANT-DfY5oA" name="USBProtocol">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_6tx6sIB-EeSeANT-DfY5oA" name="USBProtocol"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_B2K5sIB_EeSeANT-DfY5oA" name="USBProtocol"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_CSN8gIB_EeSeANT-DfY5oA" name="USBProtocol~"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_CwJOoIB_EeSeANT-DfY5oA" name="USBProtocolIo">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_w-GT4IB_EeSeANT-DfY5oA" name="data">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_VSn4AIFTEeSxK_Fl3WspFw" name="data">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_8I6RgBydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_eWwv4ICAEeSeANT-DfY5oA" name="eod"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_B9ND4ICBEeSeANT-DfY5oA" name="ack"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_C9k7wICBEeSeANT-DfY5oA" name="resend"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="__0CyYMW1EeSd16LgMAJOmw" name="Eject"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_JWL3AMW2EeSd16LgMAJOmw" name="deviceClass">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_QTRk8MW2EeSd16LgMAJOmw" name="deviceClassID" type="_bFD18IB9EeSeANT-DfY5oA"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_2QQ1kMXiEeSsD5C2f30z-g" name="status">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_-CSncMXiEeSsD5C2f30z-g" name="percent">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_CgVgEMXjEeSsD5C2f30z-g" name="error">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_JfGpAMXjEeSsD5C2f30z-g" name="errorCode" type="_Me6CAMXjEeSsD5C2f30z-g"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_CubJ8MXkEeSsD5C2f30z-g" name="connect"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_MHzsIICAEeSeANT-DfY5oA" name="setDeviceBusID">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_5x_NgIFSEeSxK_Fl3WspFw" name="busId" effect="read">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_xW_ZgMXiEeSsD5C2f30z-g" name="getDeviceClass"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Realization" xmi:id="_KbphwIB_EeSeANT-DfY5oA" client="_6tx6sIB-EeSeANT-DfY5oA" supplier="_B2K5sIB_EeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:Realization" xmi:id="_K4a9UIB_EeSeANT-DfY5oA" client="_6tx6sIB-EeSeANT-DfY5oA" supplier="_CwJOoIB_EeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_LqNmoIB_EeSeANT-DfY5oA" client="_6tx6sIB-EeSeANT-DfY5oA" supplier="_CSN8gIB_EeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_Meva4IB_EeSeANT-DfY5oA" client="_6tx6sIB-EeSeANT-DfY5oA" supplier="_CwJOoIB_EeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_oDVi4ICAEeSeANT-DfY5oA" name="*"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_sU9wIICAEeSeANT-DfY5oA" name="setDeviceBusID" operation="_MHzsIICAEeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_sd1YQICAEeSeANT-DfY5oA" name="data" operation="_w-GT4IB_EeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_sh4x0ICAEeSeANT-DfY5oA" name="eod" operation="_eWwv4ICAEeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_E41HgICBEeSeANT-DfY5oA" name="ack" operation="_B9ND4ICBEeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_E6zdcICBEeSeANT-DfY5oA" name="resend" operation="_C9k7wICBEeSeANT-DfY5oA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="__0FOoMW1EeSd16LgMAJOmw" name="Eject" operation="__0CyYMW1EeSd16LgMAJOmw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_JWO6UMW2EeSd16LgMAJOmw" name="deviceClass" operation="_JWL3AMW2EeSd16LgMAJOmw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_xXCc0MXiEeSsD5C2f30z-g" name="getDeviceClass" operation="_xW_ZgMXiEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_2QT44MXiEeSsD5C2f30z-g" name="status" operation="_2QQ1kMXiEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_CgX8UMXjEeSsD5C2f30z-g" name="error" operation="_CgVgEMXjEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_CudmMMXkEeSsD5C2f30z-g" name="connect" operation="_CubJ8MXkEeSsD5C2f30z-g"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_2hCXIMXPEeSsD5C2f30z-g" name="OSCommand">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_4zRfgMXPEeSsD5C2f30z-g" name="OSCommand"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_4zUi0MXPEeSsD5C2f30z-g" name="OSCommand">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_XNJA8MXQEeSsD5C2f30z-g" name="LaunchApp">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_dyEtkMXQEeSsD5C2f30z-g" name="appType" type="_5luYcMQUEeSirL7ina4YrA"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Realization" xmi:id="_4zYNMMXPEeSsD5C2f30z-g" name="ProtocolRealizesIncomingInterface" client="_4zRfgMXPEeSsD5C2f30z-g" supplier="_4zUi0MXPEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_4zZbUMXPEeSsD5C2f30z-g" name="OSCommand~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_kqwcoMXQEeSsD5C2f30z-g" name="AppLaunched"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_oJKdMMXQEeSsD5C2f30z-g" name="AppLaunchFail"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_4zceoMXPEeSsD5C2f30z-g" name="ProtocolUsesOutgoingInterface" client="_4zRfgMXPEeSsD5C2f30z-g" supplier="_4zZbUMXPEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_4zdswMXPEeSsD5C2f30z-g" name="OSCommandIo"/>
        <packagedElement xmi:type="uml:Realization" xmi:id="_4zgwEMXPEeSsD5C2f30z-g" name="ProtocolRealizesSymInterface" client="_4zRfgMXPEeSsD5C2f30z-g" supplier="_4zdswMXPEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_4zh-MMXPEeSsD5C2f30z-g" name="ProtocolUsesSymInterface" client="_4zRfgMXPEeSsD5C2f30z-g" supplier="_4zdswMXPEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_4zilQMXPEeSsD5C2f30z-g" name="*"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_XNMEQMXQEeSsD5C2f30z-g" name="LaunchApp" operation="_XNJA8MXQEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_kqzf8MXQEeSsD5C2f30z-g" name="AppLaunched" operation="_kqwcoMXQEeSsD5C2f30z-g"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_oJNggMXQEeSsD5C2f30z-g" name="AppLaunchFail" operation="_oJKdMMXQEeSsD5C2f30z-g"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_l6sCMMXKEeSsD5C2f30z-g" name="Enums and Constants">
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_5luYcMQUEeSirL7ina4YrA" name="AppType">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_7OV8EMQUEeSirL7ina4YrA" name="WordProcessor"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_9DEpEMQUEeSirL7ina4YrA" name="Sync"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_bFD18IB9EeSeANT-DfY5oA" name="USBDeviceClasses">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_flU8IIB9EeSeANT-DfY5oA" name="Unspecified"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_hapfAIB9EeSeANT-DfY5oA" name="Audio"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_jYBKoIB9EeSeANT-DfY5oA" name="Communication_CDCControl"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_MWmoAIB-EeSeANT-DfY5oA" name="HID-HumanInterfaceDevice"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_ltHZwIB9EeSeANT-DfY5oA" name="PID-PhysicalInterfaceDevice"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_oyczAIB9EeSeANT-DfY5oA" name="Image"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_qBD7MIB9EeSeANT-DfY5oA" name="Printer"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_u6g9cIB9EeSeANT-DfY5oA" name="MassStorage"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_ziE-cIB9EeSeANT-DfY5oA" name="USBHub"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_092_8IB9EeSeANT-DfY5oA" name="CDC-Data"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_-D5-cIB9EeSeANT-DfY5oA" name="SmartCard"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="__sfF0IB9EeSeANT-DfY5oA" name="ContentSecurity"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_BeLF4IB-EeSeANT-DfY5oA" name="Video"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_DQsMYIB-EeSeANT-DfY5oA" name="PersonalHealthcare"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_GWTScIB-EeSeANT-DfY5oA" name="AV-AudioVideo"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_XSE3EIB-EeSeANT-DfY5oA" name="Billboard"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_ZONzoIB-EeSeANT-DfY5oA" name="DiagnosticDevice"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_bR3tcIB-EeSeANT-DfY5oA" name="WirelessController"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_dAhnoIB-EeSeANT-DfY5oA" name="Miscellaneous"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_hpQtUIB-EeSeANT-DfY5oA" name="ApplicationSpecific-IrDA_TMC_DFU"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_lWbioIB-EeSeANT-DfY5oA" name="VendorSpecific"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_e2WAMMQeEeSirL7ina4YrA" name="ResourceType">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_g395sMQeEeSirL7ina4YrA" name="PrinterDriver"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_imVgAMQeEeSirL7ina4YrA" name="StorageDriver"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_Me6CAMXjEeSsD5C2f30z-g" name="USBErrorCodes">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_Pg4lQMXjEeSsD5C2f30z-g" name="OpFail"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_Tiy7gMXjEeSsD5C2f30z-g" name="NotReady"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_Yge9gMXjEeSsD5C2f30z-g" name="OutOfSpace"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_VpjzsMXjEeSsD5C2f30z-g" name="OutOfPaper"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_eQzWUMXjEeSsD5C2f30z-g" name="LowInkToner"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_njLgoMXjEeSsD5C2f30z-g" name="PaperJam"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_H3z9EMXNEeSsD5C2f30z-g" name="System">
      <packagedElement xmi:type="uml:Class" xmi:id="_SfgCwMODEeSSS8SwKHucgQ" name="ComputerSystem" classifierBehavior="_F3llQMUeEeS9x_uTNp8Ezw" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_bS384MODEeSSS8SwKHucgQ" name="computer" visibility="protected" type="_fMulcH_6EeSOLqU6j-e_hg" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_3r4oQAutEeWCGuiso4e4-g" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_3r7rkAutEeWCGuiso4e4-g" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_wAf-UMOKEeSSS8SwKHucgQ" name="user" visibility="protected" type="_og5ZMMOKEeSSS8SwKHucgQ" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_-2IBYAutEeWCGuiso4e4-g"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_-2IocAutEeWCGuiso4e4-g" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_tcmSoMOUEeSy9Z1Kd1VJnQ" name="printer" visibility="protected" type="_CperoMOLEeSSS8SwKHucgQ" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_9889sAutEeWCGuiso4e4-g"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_98-L0AutEeWCGuiso4e4-g" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_u28wwMOUEeSy9Z1Kd1VJnQ" name="massStorage" visibility="protected" type="_FTGZQMOLEeSSS8SwKHucgQ" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_68qcgAutEeWCGuiso4e4-g"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_68rqoAutEeWCGuiso4e4-g" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_Uh604AutEeWCGuiso4e4-g" name="frame" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_TWVjwGtVEeSCmtGQ-V4nzg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_W30jAAuyEeWCGuiso4e4-g" name="initStatus" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_f_gCwAu-EeWCGuiso4e4-g" name="timer" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_2cdikAu_EeWCGuiso4e4-g" name="timerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_qrYScAvFEeWCGuiso4e4-g" name="_dummiest" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_ECQakBUbEeWFQ7RnHw84Pw" name="numSec" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
        </ownedAttribute>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_DOQBQMO6EeSxS9_G15_gSg" name="Connector3">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_DOQoUMO6EeSxS9_G15_gSg" partWithPort="_wAf-UMOKEeSSS8SwKHucgQ" role="_J5xTgMO5EeSxS9_G15_gSg">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_DOQoUcO6EeSxS9_G15_gSg" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_DOQoUsO6EeSxS9_G15_gSg" value="1"/>
          </end>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_DOQoU8O6EeSxS9_G15_gSg" partWithPort="_bS384MODEeSSS8SwKHucgQ" role="_m1ajcMO5EeSxS9_G15_gSg">
            <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_DOQoVMO6EeSxS9_G15_gSg" value="1"/>
            <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_DOQoVcO6EeSxS9_G15_gSg" value="1"/>
          </end>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_CZ02sO1nEeSNVueSbviXfA" name="Connector4">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_CZ1dwO1nEeSNVueSbviXfA" partWithPort="_tcmSoMOUEeSy9Z1Kd1VJnQ" role="_SSMs8MOLEeSSS8SwKHucgQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_CZ1dwe1nEeSNVueSbviXfA" partWithPort="_bS384MODEeSSS8SwKHucgQ" role="_oyJrcIFWEeSxK_Fl3WspFw"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_DVHaQO1nEeSNVueSbviXfA" name="Connector5">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_DVIoYO1nEeSNVueSbviXfA" partWithPort="_u28wwMOUEeSy9Z1Kd1VJnQ" role="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_DVIoYe1nEeSNVueSbviXfA" partWithPort="_bS384MODEeSSS8SwKHucgQ" role="_oyJrcIFWEeSxK_Fl3WspFw"/>
        </ownedConnector>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_F3llQMUeEeS9x_uTNp8Ezw" name="ComputerSystem_SM" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_IAM3kMUeEeS9x_uTNp8Ezw" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_PQTBEMUeEeS9x_uTNp8Ezw" name="incarnateUser" source="_83cecAu-EeWCGuiso4e4-g" target="_h-CpgAuyEeWCGuiso4e4-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Z4ZoMMUeEeS9x_uTNp8Ezw" name="incarnateUser">
                <language>C++</language>
                <body>/**
 * Incarnate the user
 */
time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is incarnating a user.&quot; &lt;&lt; std::endl;

UMLRTCapsuleId userId = frame.incarnate(user, User);
initStatus = userId.isValid();

</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_AW6JkBVwEeWTkNGQfAIBEw" name="onTimeout" port="_f_gCwAu-EeWCGuiso4e4-g">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_yXj1oAuyEeWCGuiso4e4-g" name="userOK" guard="_J_WmUAuzEeWCGuiso4e4-g" source="_h-CpgAuyEeWCGuiso4e4-g" target="_Nin-UMUeEeS9x_uTNp8Ezw">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_J_WmUAuzEeWCGuiso4e4-g" name="userOK">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_J_WmUQuzEeWCGuiso4e4-g" name="userOK">
                  <language>C++</language>
                  <body>return(initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_0UN1wA4GEeWZmqO69MGcNA" name="userIncarnated">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] incarnated the user.&quot; &lt;&lt; std::endl;</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_zHs5IAuyEeWCGuiso4e4-g" name="userNOK" guard="_aIfNEAuzEeWCGuiso4e4-g" source="_h-CpgAuyEeWCGuiso4e4-g" target="_tBnrsAuyEeWCGuiso4e4-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_aIfNEAuzEeWCGuiso4e4-g" name="userNOK">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_aIfNEQuzEeWCGuiso4e4-g" name="initStatusNOK">
                  <language>C++</language>
                  <body>return(!initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_uITGEA4GEeWZmqO69MGcNA" name="errorIncarnatingUser">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] FAILed to incarnate the user!&quot; &lt;&lt; std::endl;</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_J7s-8Au_EeWCGuiso4e4-g" name="setComputerInitTimer" source="_NC-08MUeEeS9x_uTNp8Ezw" target="_ZDdWUAvBEeWCGuiso4e4-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_BJHSgAvAEeWCGuiso4e4-g" name="setComputerTimer">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is initializing &quot;;

numSec = 20;
timerID = timer.informIn(UMLRTTimespec(numSec,0));
initStatus = timerID.isValid();
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_W5o1AAu_EeWCGuiso4e4-g" name="incarnateDevices" source="_u8HzEAu-EeWCGuiso4e4-g" target="_wkR8UAvBEeWCGuiso4e4-g">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_02LZ4AvCEeWCGuiso4e4-g" name="incarnateDevicesAndWait">
                <language>C++</language>
                <body>/**
 * Initialise the devices
 */
/**
 * Incarnate the local printer
 */
time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] local printer incarnation&quot;;

UMLRTCapsuleId printerId = frame.incarnate(printer, LocalPrinter);
bool printerStatus = printerId.isValid();
if ( printerStatus ) {
	std::cout &lt;&lt; &quot; successful.&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; FAILED!&quot; &lt;&lt; std::endl;
}


/**
 * Incarnate the mass storage device
 */
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] mass storage incarnation&quot;;

UMLRTCapsuleId storageId = frame.incarnate(massStorage, ExtMassStorage);
bool storageStatus = storageId.isValid();
if ( storageStatus ) {
	std::cout &lt;&lt; &quot; successful.&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; FAILED!&quot; &lt;&lt; std::endl;
}

bool timerStatus = false;
if ( printerStatus &amp;&amp; storageStatus ) {
	/**
	 * Set timer to wait for device initialisation
	 */
	numSec = 15;
	timerID = timer.informIn(UMLRTTimespec(numSec,0));
	timerStatus = timerID.isValid();

	time( &amp;currentTime );
	localTime = localtime( &amp;currentTime );
	std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

	std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] &quot;;
	if ( ! timerStatus ) {
		std::cout &lt;&lt; &quot;FAILED to &quot;;
	}
	std::cout &lt;&lt; &quot;set &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timout for device initialization wait.&quot; &lt;&lt; std::endl;
}

initStatus = ( printerStatus &amp;&amp; storageStatus &amp;&amp; timerStatus);
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_vlDCAAvDEeWCGuiso4e4-g" name="onComputerTimeout" port="_f_gCwAu-EeWCGuiso4e4-g">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_ecM8oAvBEeWCGuiso4e4-g" name="timerOK" guard="_KhKVEAvCEeWCGuiso4e4-g" source="_ZDdWUAvBEeWCGuiso4e4-g" target="_u8HzEAu-EeWCGuiso4e4-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_KhKVEAvCEeWCGuiso4e4-g" name="validTimer">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_KhKVEQvCEeWCGuiso4e4-g" name="validTimer">
                  <language>C++</language>
                  <body>return(initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_wGf_gA4DEeWZmqO69MGcNA" name="TimerSet">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; and set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_gDAiYAvBEeWCGuiso4e4-g" name="compTimerFail" guard="_j4M5AAvGEeWCGuiso4e4-g" source="_ZDdWUAvBEeWCGuiso4e4-g" target="_tBnrsAuyEeWCGuiso4e4-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_j4M5AAvGEeWCGuiso4e4-g" name="Failed">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_j4M5AQvGEeWCGuiso4e4-g" name="Failed">
                  <language>C++</language>
                  <body>return(!initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rbKRwA4DEeWZmqO69MGcNA" name="TimerFail">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; but FAILed to set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer!&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_g65XMAvCEeWCGuiso4e4-g" name="Failed" guard="_Z956cAvDEeWCGuiso4e4-g" source="_wkR8UAvBEeWCGuiso4e4-g" target="_tBnrsAuyEeWCGuiso4e4-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_Z956cAvDEeWCGuiso4e4-g" name="Failed">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_Z956cQvDEeWCGuiso4e4-g" name="failure">
                  <language>C++</language>
                  <body>return(!initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mWsncA4FEeWZmqO69MGcNA" name="IncarnateFail">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] did not incarnate all devices!&quot; &lt;&lt; std::endl;</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_ioaB4AvCEeWCGuiso4e4-g" name="Success" guard="_hrbm0AvDEeWCGuiso4e4-g" source="_wkR8UAvBEeWCGuiso4e4-g" target="_83cecAu-EeWCGuiso4e4-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_hrbm0AvDEeWCGuiso4e4-g">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_hrbm0QvDEeWCGuiso4e4-g" name="Success">
                  <language>C++</language>
                  <body>return(initStatus);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_TOqxMA4GEeWZmqO69MGcNA" name="devicesIncarnated">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] incarnated all external devices!&quot; &lt;&lt; std::endl;

// context()->debugOutputModel();
</body>
              </effect>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_NC-08MUeEeS9x_uTNp8Ezw" name="Initial1"/>
            <subvertex xmi:type="uml:State" xmi:id="_Nin-UMUeEeS9x_uTNp8Ezw" name="Running">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_1wK1AO4KEeSAlbC0LA6o5Q" name="Running">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is {Running}.&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_h-CpgAuyEeWCGuiso4e4-g" name="userOK?" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_tBnrsAuyEeWCGuiso4e4-g" name="Failure">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_mKmHgAvIEeWCGuiso4e4-g" name="ComputerSystemFailed">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; (localTime->tm_year + 1900) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; (localTime->tm_mon + 1) &lt;&lt; &quot;.&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_mday &lt;&lt; &quot; &quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] terminated in failure!&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_u8HzEAu-EeWCGuiso4e4-g" name="WaitingForComputerInit">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_GZec4A4FEeWZmqO69MGcNA" name="waitingForComputerInit">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is waiting for computer initialisation {WaitingForComputerInit}.&quot; &lt;&lt; std::endl;
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_83cecAu-EeWCGuiso4e4-g" name="WaitingForDeviceInit">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_eZK6wA4GEeWZmqO69MGcNA" name="waitForDeviceInit">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;] is waiting for external device initialization.&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_ZDdWUAvBEeWCGuiso4e4-g" name="timerOK?" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_wkR8UAvBEeWCGuiso4e4-g" name="initOK?" kind="choice"/>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_og5ZMMOKEeSSS8SwKHucgQ" name="User" classifierBehavior="_-AYDoMO4EeSxS9_G15_gSg" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_J5xTgMO5EeSxS9_G15_gSg" name="computerPort" type="_vOIpQMO2EeSxS9_G15_gSg" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_0W-4cMUhEeS9x_uTNp8Ezw" name="timer" visibility="public" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_JoJRcBaOEeWD0440ocvGbg" name="numSec" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_O2UmgBaOEeWD0440ocvGbg" name="timerID" visibility="protected" aggregation="composite">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_js2k8BaYEeWD0440ocvGbg" name="status" visibility="protected" aggregation="composite">
          <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_-AYDoMO4EeSxS9_G15_gSg" name="User_SM" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_-3QBQMO4EeSxS9_G15_gSg" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_hjkPUMO5EeSxS9_G15_gSg" name="initialize" source="_ebPzgMO5EeSxS9_G15_gSg" target="_T-PT0BaUEeWD0440ocvGbg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_b3oZ8MWrEeS9x_uTNp8Ezw" name="Initialize_USER">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] initializing&quot;;

numSec = 15;
timerID = timer.informIn(UMLRTTimespec(numSec,0));
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_lys4IBaNEeWD0440ocvGbg" name="onTimeout1" source="_hADSkMO5EeSxS9_G15_gSg" target="_pwd0kBaVEeWD0440ocvGbg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_laox4BaXEeWD0440ocvGbg" name="saveDocument">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)]&quot;;

bool sendStatus = computerPort.saveDocument().send();

//numSec = 10;
timerID = timer.informIn(UMLRTTimespec(numSec,0));

status = sendStatus &amp;&amp; timerID.isValid();
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_HpnOkBaWEeWD0440ocvGbg" name="onTimeout" port="_0W-4cMUhEeS9x_uTNp8Ezw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_nTBbYBaNEeWD0440ocvGbg" name="onTimeout2" source="_T6h8sBaNEeWD0440ocvGbg" target="_9FTvQBbKEeWa4sJtLVaM7A">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_XefLsJJMEeWg8uhgJTo7AQ" name="saveTimout">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] Save timeout received&quot; &lt;&lt; std::endl;
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_MPje8BaWEeWD0440ocvGbg" name="onTimeout" port="_0W-4cMUhEeS9x_uTNp8Ezw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_oLCBcBaNEeWD0440ocvGbg" name="onTimeout3" source="_asvQUBaNEeWD0440ocvGbg" target="_pDk9kBaOEeWD0440ocvGbg">
              <trigger xmi:type="uml:Trigger" xmi:id="_kZTtMBaWEeWD0440ocvGbg" name="onTimeout" port="_0W-4cMUhEeS9x_uTNp8Ezw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_FKR60BaVEeWD0440ocvGbg" name="initTimerSet" guard="_aEu7gBaVEeWD0440ocvGbg" source="_T-PT0BaUEeWD0440ocvGbg" target="_hADSkMO5EeSxS9_G15_gSg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_aEu7gBaVEeWD0440ocvGbg" name="timerValid">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_aEu7gRaVEeWD0440ocvGbg" name="timerValid">
                  <language>C++</language>
                  <body>return(timerID.isValid());</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_EY4oMBaXEeWD0440ocvGbg" name="initTimerSet">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; and set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_F0U9YBaVEeWD0440ocvGbg" name="initTimerFail" guard="_lJFZwBaVEeWD0440ocvGbg" source="_T-PT0BaUEeWD0440ocvGbg" target="_pDk9kBaOEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_lJFZwBaVEeWD0440ocvGbg" name="invalidTimer">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_lJFZwRaVEeWD0440ocvGbg">
                  <language>C++</language>
                  <body>return(!timerID.isValid());</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_QFvQ4BaXEeWD0440ocvGbg" name="initTimerFail">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; but FAILed to set a &quot; &lt;&lt; numSec &lt;&lt; &quot; seconds timer.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_5m4ToBaVEeWD0440ocvGbg" guard="_Q9XxkBaZEeWD0440ocvGbg" source="_pwd0kBaVEeWD0440ocvGbg" target="_T6h8sBaNEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_Q9XxkBaZEeWD0440ocvGbg" name="saveOK">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_Q9XxkRaZEeWD0440ocvGbg" name="saveOK">
                  <language>C++</language>
                  <body>return(status);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="__KXC8BaYEeWD0440ocvGbg" name="saveRequested">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; asked for the document to be saved.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_9nd0MBaVEeWD0440ocvGbg" guard="_VPw-YBaaEeWD0440ocvGbg" source="_r9cCcBaVEeWD0440ocvGbg" target="_asvQUBaNEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_VPw-YBaaEeWD0440ocvGbg" name="printSet">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_VPw-YRaaEeWD0440ocvGbg" name="printSet">
                  <language>C++</language>
                  <body>return(status);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2Q8J0JLcEeWTl7q8dOahXg" name="printRequested">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; asked for the document to be printed.&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_xs7fYBaWEeWD0440ocvGbg" guard="_ZfQ6IBaZEeWD0440ocvGbg" source="_pwd0kBaVEeWD0440ocvGbg" target="_pDk9kBaOEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_ZfQ6IBaZEeWD0440ocvGbg" name="saveFail">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_ZfQ6IRaZEeWD0440ocvGbg" name="saveFail">
                  <language>C++</language>
                  <body>return(!status);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_E7D2QBaZEeWD0440ocvGbg" name="saveFailed">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; FAILed to ask for the document to be saved!&quot;;

if ( timerID.isValid() ) {
	std::cout &lt;&lt; &quot; - FAILed to send message!&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; FAILed to set timer!&quot; &lt;&lt; std::endl;
}
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_ykTzUBaWEeWD0440ocvGbg" guard="_a5ow8BaaEeWD0440ocvGbg" source="_r9cCcBaVEeWD0440ocvGbg" target="_pDk9kBaOEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_a5ow8BaaEeWD0440ocvGbg" name="printFail">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_a5ow8RaaEeWD0440ocvGbg" name="printFail">
                  <language>C++</language>
                  <body>return(!status);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_uAQGAJLcEeWTl7q8dOahXg" name="printFailure">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot; FAILed to ask for the document to be printed!&quot;;

if ( timerID.isValid() ) {
	std::cout &lt;&lt; &quot; - FAILed to send message!&quot; &lt;&lt; std::endl;
} else {
	std::cout &lt;&lt; &quot; FAILed to set timer!&quot; &lt;&lt; std::endl;
}</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_qJVUoBaiEeWD0440ocvGbg" source="_asvQUBaNEeWD0440ocvGbg" target="_4BUksBaNEeWD0440ocvGbg"/>
            <transition xmi:type="uml:Transition" xmi:id="_CmFQMBbLEeWa4sJtLVaM7A" name="isFalsePrintDoc" guard="_aMC04BbLEeWa4sJtLVaM7A" source="_9FTvQBbKEeWa4sJtLVaM7A" target="_r9cCcBaVEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_aMC04BbLEeWa4sJtLVaM7A" name="isFalse">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_aMC04RbLEeWa4sJtLVaM7A" name="isFalse">
                  <language>C++</language>
                  <body>return(false);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_NakGcBbLEeWa4sJtLVaM7A" name="printDoc">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;]&quot;;

bool sendStatus = computerPort.printDocument().send();

//numSec = 10;
timerID = timer.informIn(UMLRTTimespec(numSec,0));

status = sendStatus &amp;&amp; timerID.isValid();
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_DanrgBbLEeWa4sJtLVaM7A" name="isTrueDone" guard="_TjYe0BbLEeWa4sJtLVaM7A" source="_9FTvQBbKEeWa4sJtLVaM7A" target="_4BUksBaNEeWD0440ocvGbg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_TjYe0BbLEeWa4sJtLVaM7A" name="isTrue">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_TjYe0RbLEeWa4sJtLVaM7A" name="isTrue">
                  <language>C++</language>
                  <body>return(true);</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_DCwnAJJPEeWg8uhgJTo7AQ" name="SuccessfulRun">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );

std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot;&lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] Successful Run!&quot; &lt;&lt; std::endl;
</body>
              </effect>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_ebPzgMO5EeSxS9_G15_gSg" name="Initial"/>
            <subvertex xmi:type="uml:State" xmi:id="_hADSkMO5EeSxS9_G15_gSg" name="Alive">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_gwa88Oz_EeSEsOihEv1CcQ" name="UserIsAlive">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] is alive!&quot; &lt;&lt; std::endl;
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_T6h8sBaNEeWD0440ocvGbg" name="Waiting4DocSave">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="__09VoJJLEeWg8uhgJTo7AQ" name="Waiting4DocSave_EN">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] user is {Waiting4DocSave}&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_asvQUBaNEeWD0440ocvGbg" name="Waiting4DocPrint">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_7CiQkJLcEeWTl7q8dOahXg" name="wait4Print">
                <language>C++</language>
                <body>std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] user is {Waiting4DocPrint}&quot; &lt;&lt; std::endl;</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_4BUksBaNEeWD0440ocvGbg" name="TestDone">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_f5R6wBaaEeWD0440ocvGbg" name="testDone">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] is finished testing.&quot; &lt;&lt; std::endl;

std::exit(EXIT_SUCCESS); // successful execution
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_pDk9kBaOEeWD0440ocvGbg" name="FAILED">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_m7LQMBaaEeWD0440ocvGbg" name="testFailed">
                <language>C++</language>
                <body>time_t currentTime;
struct tm *localTime;
time( &amp;currentTime );
localTime = localtime( &amp;currentTime );
std::cout &lt;&lt; std::setfill('0') &lt;&lt; &quot;[&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_min &lt;&lt; &quot;:&quot; &lt;&lt; std::setw(2) &lt;&lt; localTime->tm_sec &lt;&lt; &quot;] &quot;;

std::cout &lt;&lt; &quot;[&quot; &lt;&lt; this->getName() &lt;&lt; &quot;(&quot; &lt;&lt; this->getClass()->name &lt;&lt; &quot;)] {FAILED}!&quot;;

std::exit(EXIT_FAILURE); // unsuccessful execution
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_T-PT0BaUEeWD0440ocvGbg" name="tid1?" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_pwd0kBaVEeWD0440ocvGbg" name="tid2?" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_r9cCcBaVEeWD0440ocvGbg" name="tid3?" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_9FTvQBbKEeWa4sJtLVaM7A" name="TesterChoice" kind="choice"/>
          </region>
        </ownedBehavior>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_s8h5kO1kEeSNVueSbviXfA" name="Top" isActive="true">
      <ownedAttribute xmi:type="uml:Property" xmi:id="_3f1gQO1kEeSNVueSbviXfA" name="computerSystem" visibility="protected" type="_SfgCwMODEeSSS8SwKHucgQ"/>
    </packagedElement>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_YSrkcX_6EeSOLqU6j-e_hg">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_YSrkcn_6EeSOLqU6j-e_hg" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_v0WsUIB5EeSeANT-DfY5oA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_v1QEMIB5EeSeANT-DfY5oA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_BBz20IB6EeSeANT-DfY5oA" base_Class="_fMulcH_6EeSOLqU6j-e_hg"/>
  <UMLRealTime:CapsulePart xmi:id="_Q7rdEIB7EeSeANT-DfY5oA" base_Property="_p_mqAIB6EeSeANT-DfY5oA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_0kN7cIB-EeSeANT-DfY5oA" base_Package="_vn-D4IB-EeSeANT-DfY5oA"/>
  <UMLRealTime:Protocol xmi:id="_-6XP4IB-EeSeANT-DfY5oA" base_Collaboration="_6tx6sIB-EeSeANT-DfY5oA"/>
  <UMLRealTime:RTMessageSet xmi:id="_iXWF4IB_EeSeANT-DfY5oA" base_Interface="_B2K5sIB_EeSeANT-DfY5oA"/>
  <UMLRealTime:RTMessageSet xmi:id="_kMr24IB_EeSeANT-DfY5oA" base_Interface="_CSN8gIB_EeSeANT-DfY5oA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_msdE8IB_EeSeANT-DfY5oA" base_Interface="_CwJOoIB_EeSeANT-DfY5oA" rtMsgKind="inOut"/>
  <UMLRealTime:RTPort xmi:id="_51RokICCEeSeANT-DfY5oA" base_Port="_ui7KkICCEeSeANT-DfY5oA"/>
  <UMLRealTime:RTPort xmi:id="_5P1ysICiEeSeANT-DfY5oA" isWired="false" base_Port="_dmbmsICiEeSeANT-DfY5oA"/>
  <UMLRealTime:Capsule xmi:id="_uWX_sICrEeSYmJvm6id8mw" base_Class="_ZUBdgIB6EeSeANT-DfY5oA"/>
  <UMLRealTime:RTPort xmi:id="_eRPSsICsEeSYmJvm6id8mw" isWired="false" base_Port="_NFL2YICsEeSYmJvm6id8mw"/>
  <UMLRealTime:RTPort xmi:id="_Ded9EIFXEeSxK_Fl3WspFw" base_Port="_oyJrcIFWEeSxK_Fl3WspFw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_x4gVsMNyEeSSS8SwKHucgQ" base_StateMachine="_2cxfEICrEeSYmJvm6id8mw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_0ZOmAMNyEeSSS8SwKHucgQ" base_Region="_3ifJ8ICrEeSYmJvm6id8mw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_4YJSoMNyEeSSS8SwKHucgQ" base_Pseudostate="_75RkAICrEeSYmJvm6id8mw"/>
  <UMLRealTime:Capsule xmi:id="_T2g5AMODEeSSS8SwKHucgQ" base_Class="_SfgCwMODEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_26PPkMOFEeSSS8SwKHucgQ" base_Class="_vk5ZsMOFEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_3rCaYMOFEeSSS8SwKHucgQ" base_Class="_z6QQYMOFEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_LoxXUMOKEeSSS8SwKHucgQ" base_Class="_9YrV0MOJEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_qd1nAMOKEeSSS8SwKHucgQ" base_Class="_og5ZMMOKEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_IIl_sMOLEeSSS8SwKHucgQ" base_Class="_CperoMOLEeSSS8SwKHucgQ"/>
  <UMLRealTime:Capsule xmi:id="_I2hcsMOLEeSSS8SwKHucgQ" base_Class="_FTGZQMOLEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_ZIvRgMOMEeSSS8SwKHucgQ" base_StateMachine="_Qm-r0MOMEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_cy3Z4MOMEeSSS8SwKHucgQ" base_Region="_Shge0MOMEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_p4MRYMOMEeSSS8SwKHucgQ" base_Pseudostate="_oTeWUMOMEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTState xmi:id="_0wQnIMOMEeSSS8SwKHucgQ" base_State="_tkuNgMOMEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTState xmi:id="_V-vv0MOOEeSSS8SwKHucgQ" base_State="_TRQO0MOOEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_gbwNUMOmEeSy9Z1Kd1VJnQ" base_StateMachine="_cv6NsMOmEeSy9Z1Kd1VJnQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_ingTMMOmEeSy9Z1Kd1VJnQ" base_Region="_d298YMOmEeSy9Z1Kd1VJnQ"/>
  <UMLRealTime:Capsule xmi:id="_QB7BsMOyEeSxS9_G15_gSg" base_Class="_N2fr8MOyEeSxS9_G15_gSg"/>
  <UMLRealTime:Protocol xmi:id="_vOKecMO2EeSxS9_G15_gSg" base_Collaboration="_vOIpQMO2EeSxS9_G15_gSg"/>
  <UMLRealTime:RTMessageSet xmi:id="_vOMToMO2EeSxS9_G15_gSg" base_Interface="_vOLFgMO2EeSxS9_G15_gSg"/>
  <UMLRealTime:RTMessageSet xmi:id="_vOPW8MO2EeSxS9_G15_gSg" base_Interface="_vOOI0MO2EeSxS9_G15_gSg" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_vOSaQMO2EeSxS9_G15_gSg" base_Interface="_vORMIMO2EeSxS9_G15_gSg" rtMsgKind="inOut"/>
  <UMLRealTime:RTPort xmi:id="_MWYf4MO5EeSxS9_G15_gSg" base_Port="_J5xTgMO5EeSxS9_G15_gSg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_aXLhIMO5EeSxS9_G15_gSg" base_StateMachine="_-AYDoMO4EeSxS9_G15_gSg"/>
  <UMLRTStateMachines:RTRegion xmi:id="_cbzrUMO5EeSxS9_G15_gSg" base_Region="_-3QBQMO4EeSxS9_G15_gSg"/>
  <UMLRealTime:Capsule xmi:id="_4eZ98MO6EeSxS9_G15_gSg" base_Class="_2WM7UMO6EeSxS9_G15_gSg"/>
  <UMLRealTime:CapsulePart xmi:id="_Jjrc0MO7EeSxS9_G15_gSg" base_Property="_EFn4sMO7EeSxS9_G15_gSg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_pAM_YMQOEeSirL7ina4YrA" base_StateMachine="_j6H2YMQOEeSirL7ina4YrA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_sVSE0MQOEeSirL7ina4YrA" base_Region="_lPuXYMQOEeSirL7ina4YrA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_tlw1QMQOEeSirL7ina4YrA" base_Pseudostate="_rMOyEMQOEeSirL7ina4YrA"/>
  <UMLRTStateMachines:RTState xmi:id="_v_H5UMQOEeSirL7ina4YrA" base_State="_uPDp4MQOEeSirL7ina4YrA"/>
  <UMLRealTime:RTPort xmi:id="_1lgoIMQQEeSirL7ina4YrA" base_Port="_JKtYAMQPEeSirL7ina4YrA"/>
  <UMLRealTime:CapsulePart xmi:id="_dnKFsMQdEeSirL7ina4YrA" base_Property="_PPdAUMQdEeSirL7ina4YrA"/>
  <UMLRealTime:CapsulePart xmi:id="_erbmIMQdEeSirL7ina4YrA" base_Property="_a5T_YMQdEeSirL7ina4YrA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_sSRPQMQdEeSirL7ina4YrA" base_Package="_pfCSoMQdEeSirL7ina4YrA"/>
  <UMLRealTime:Protocol xmi:id="_sSre8MQdEeSirL7ina4YrA" base_Collaboration="_sSppwMQdEeSirL7ina4YrA"/>
  <UMLRealTime:RTMessageSet xmi:id="_sSvwYMQdEeSirL7ina4YrA" base_Interface="_sSsGAMQdEeSirL7ina4YrA"/>
  <UMLRealTime:RTMessageSet xmi:id="_sSzawMQdEeSirL7ina4YrA" base_Interface="_sSxlkMQdEeSirL7ina4YrA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_sS3FIMQdEeSirL7ina4YrA" base_Interface="_sS1P8MQdEeSirL7ina4YrA" rtMsgKind="inOut"/>
  <UMLRealTime:ProtocolContainer xmi:id="_224dgMQdEeSirL7ina4YrA" base_Package="_TL3RUMO2EeSxS9_G15_gSg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_cBrbAMQwEeSsW5rXQX5TZg" base_StateMachine="_TT09IIFgEeSuOriThrPJWQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_dU-O4MQwEeSsW5rXQX5TZg" base_Region="_U3yDMIFgEeSuOriThrPJWQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ecXUwMQwEeSsW5rXQX5TZg" base_Pseudostate="_YntRkIFgEeSuOriThrPJWQ"/>
  <UMLRTStateMachines:RTState xmi:id="_fUTpYMQwEeSsW5rXQX5TZg" base_State="_aIsjMIFgEeSuOriThrPJWQ"/>
  <UMLRTStateMachines:RTState xmi:id="_inPZwMQwEeSsW5rXQX5TZg" base_State="_9aW6AIFgEeSuOriThrPJWQ"/>
  <UMLRealTime:CapsulePart xmi:id="_9I7zEMUdEeS9x_uTNp8Ezw" base_Property="_bS384MODEeSSS8SwKHucgQ"/>
  <UMLRealTime:CapsulePart xmi:id="_9_jSAMUdEeS9x_uTNp8Ezw" base_Property="_wAf-UMOKEeSSS8SwKHucgQ"/>
  <UMLRealTime:CapsulePart xmi:id="_-tvNsMUdEeS9x_uTNp8Ezw" base_Property="_tcmSoMOUEeSy9Z1Kd1VJnQ"/>
  <UMLRealTime:CapsulePart xmi:id="_BKNQIMUeEeS9x_uTNp8Ezw" base_Property="_u28wwMOUEeSy9Z1Kd1VJnQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_MS9tQMUeEeS9x_uTNp8Ezw" base_StateMachine="_F3llQMUeEeS9x_uTNp8Ezw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_QfG9kMUeEeS9x_uTNp8Ezw" base_Pseudostate="_NC-08MUeEeS9x_uTNp8Ezw"/>
  <UMLRTStateMachines:RTState xmi:id="_RTJCkMUeEeS9x_uTNp8Ezw" base_State="_Nin-UMUeEeS9x_uTNp8Ezw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_SLUnwMUeEeS9x_uTNp8Ezw" base_Region="_IAM3kMUeEeS9x_uTNp8Ezw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_4y_ysMXPEeSsD5C2f30z-g" base_Package="_2hCXIMXPEeSsD5C2f30z-g"/>
  <UMLRealTime:Protocol xmi:id="_4zT7wMXPEeSsD5C2f30z-g" base_Collaboration="_4zRfgMXPEeSsD5C2f30z-g"/>
  <UMLRealTime:RTMessageSet xmi:id="_4zW_EMXPEeSsD5C2f30z-g" base_Interface="_4zUi0MXPEeSsD5C2f30z-g"/>
  <UMLRealTime:RTMessageSet xmi:id="_4zbQgMXPEeSsD5C2f30z-g" base_Interface="_4zZbUMXPEeSsD5C2f30z-g" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_4zfh8MXPEeSsD5C2f30z-g" base_Interface="_4zdswMXPEeSsD5C2f30z-g" rtMsgKind="inOut"/>
  <UMLRealTime:RTPort xmi:id="_zcbt8MXgEeSsD5C2f30z-g" base_Port="_vXWH4MXgEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_LYlM8MYAEeSsD5C2f30z-g" base_Port="_pCSIcMXOEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_B3RZUMYBEeSsD5C2f30z-g" base_Port="_5Gm08MYAEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_D0J8wMYBEeSsD5C2f30z-g" isWired="false" base_Port="_oyefIMYAEeSsD5C2f30z-g"/>
  <UMLRealTime:CapsulePart xmi:id="_PXljsMYBEeSsD5C2f30z-g" base_Property="_I8yqgMYBEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_43YbQMYCEeSsD5C2f30z-g" base_StateMachine="_tFC1oMYCEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTRegion xmi:id="_5xvxwMYCEeSsD5C2f30z-g" base_Region="_vz1-MMYCEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_A76SYMYDEeSsD5C2f30z-g" base_Pseudostate="_AE38sMYDEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTState xmi:id="_Fm0iUMYDEeSsD5C2f30z-g" base_State="_DcG-QMYDEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTState xmi:id="_EveYsMYFEeSsD5C2f30z-g" base_State="_D3UosMYFEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_4j93UMbDEeSvmLj5mtpd2g" base_Port="_w7EMQMbDEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_10DfAMbEEeSvmLj5mtpd2g" base_Pseudostate="_yNH0kMbEEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_kZxiAMbbEeSvmLj5mtpd2g" base_State="_RN478MbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_pfVGkMbbEeSvmLj5mtpd2g" base_State="_fsiW0MbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTRegion xmi:id="_qSwuoMbbEeSvmLj5mtpd2g" base_Region="_WVcEksbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_rNKhYMbbEeSvmLj5mtpd2g" base_State="_iQYMkMbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_skbPQMbbEeSvmLj5mtpd2g" base_Pseudostate="_WVfH4MbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_t0fwAMbbEeSvmLj5mtpd2g" base_Pseudostate="_W86UQMbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_uyIc8MbbEeSvmLj5mtpd2g" base_Pseudostate="_XUhjAMbbEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_7ezNwMbkEeSvmLj5mtpd2g" base_State="_Bt8igMbjEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_8snrwMbkEeSvmLj5mtpd2g" base_State="_HrCd8MbhEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_9lw6QMbkEeSvmLj5mtpd2g" base_State="_JoagwMYJEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTState xmi:id="_HsMWcMePEeSz1oN1Kl4Now" base_State="_Eytn4MePEeSz1oN1Kl4Now"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_RAX2MMdQEeSiG8QCXtAiEg" base_Pseudostate="_OIT1sMOnEeSy9Z1Kd1VJnQ"/>
  <UMLRTStateMachines:RTState xmi:id="_TaM0UMdQEeSiG8QCXtAiEg" base_State="_Pm2QQMOnEeSy9Z1Kd1VJnQ"/>
  <UMLRTStateMachines:RTState xmi:id="_UnREYMdQEeSiG8QCXtAiEg" base_State="_PG3vsMOnEeSy9Z1Kd1VJnQ"/>
  <UMLRealTime:RTPort xmi:id="_-4K5QOoCEeSISfdD9i8SIg" base_Port="_yYoMwMXOEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_AqMQgOoDEeSISfdD9i8SIg" isNotification="true" base_Port="_m1ajcMO5EeSxS9_G15_gSg"/>
  <UMLRealTime:RTPort xmi:id="_Ejlj8OoDEeSISfdD9i8SIg" base_Port="_jacOAMYBEeSsD5C2f30z-g"/>
  <UMLRealTime:RTPort xmi:id="_XO3XUOoDEeSISfdD9i8SIg" isWired="false" base_Port="_-hXZwMQZEeSirL7ina4YrA"/>
  <UMLRealTime:RTConnector xmi:id="_lTSUUOoDEeSISfdD9i8SIg" base_Connector="_xN9oQMYBEeSsD5C2f30z-g"/>
  <UMLRealTime:RTConnector xmi:id="_ToR1sOoEEeSISfdD9i8SIg" base_Connector="_SHmf8MXPEeSsD5C2f30z-g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_sW99AOoEEeSISfdD9i8SIg" base_Pseudostate="_vjKL0MeMEeSz1oN1Kl4Now"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_LO6hkOoFEeSISfdD9i8SIg" base_Pseudostate="_bshqkMbGEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_MmqXoOoFEeSISfdD9i8SIg" base_Pseudostate="_ND7NAMbHEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_OHqQUOoFEeSISfdD9i8SIg" base_State="_6wgK4MbEEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTState xmi:id="_O1iqAOoFEeSISfdD9i8SIg" base_State="_mZ_S0MbGEeSvmLj5mtpd2g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_PoHWcOoFEeSISfdD9i8SIg" base_Pseudostate="_9b6ywMeJEeSz1oN1Kl4Now"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_QS3joOoFEeSISfdD9i8SIg" base_Pseudostate="_h1RbUMeTEeSz1oN1Kl4Now"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_UZTNgOoFEeSISfdD9i8SIg" base_Pseudostate="_Ntc9AMeJEeSz1oN1Kl4Now"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_VFaFkOoFEeSISfdD9i8SIg" base_Pseudostate="_u_tRwMeSEeSz1oN1Kl4Now"/>
  <UMLRealTime:RTPort xmi:id="_Oaq2cOoGEeSISfdD9i8SIg" base_Port="_SSMs8MOLEeSSS8SwKHucgQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Tw5UQOoGEeSISfdD9i8SIg" base_Pseudostate="_RN0-gMOOEeSSS8SwKHucgQ"/>
  <UMLRealTime:RTPort xmi:id="_Yua-MOoGEeSISfdD9i8SIg" base_Port="_q4ZLUMOmEeSy9Z1Kd1VJnQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_efwDoOoGEeSISfdD9i8SIg" base_Pseudostate="_jTAHQMOmEeSy9Z1Kd1VJnQ"/>
  <UMLRealTime:RTConnector xmi:id="_IQ7bkOoHEeSISfdD9i8SIg" base_Connector="_DOQBQMO6EeSxS9_G15_gSg"/>
  <UMLRealTime:RTConnector xmi:id="_MRSbwOqNEeSlmKRr_VnIAg" base_Connector="_BzuQsOqNEeSlmKRr_VnIAg"/>
  <UMLRealTime:RTConnector xmi:id="_NyYbEOqNEeSlmKRr_VnIAg" base_Connector="_AtlvEOqNEeSlmKRr_VnIAg"/>
  <UMLRealTime:CapsulePart xmi:id="_Ph_GkOz1EeSfXf8RKMFgHQ" base_Property="_c8b1UOqLEeSlmKRr_VnIAg"/>
  <UMLRealTime:RTPort xmi:id="_XIGG4Oz2EeSfXf8RKMFgHQ" isWired="false" base_Port="_0W-4cMUhEeS9x_uTNp8Ezw"/>
  <UMLRealTime:RTPort xmi:id="_L7c8YO0DEeST5KnPUdkGIg" isWired="false" base_Port="_hwfLcO0CEeSVocSGS756bA"/>
  <UMLRealTime:RTPort xmi:id="_NxOY8O0IEeSzlZWHZcnPXA" isWired="false" base_Port="_DzjO4O0IEeSzlZWHZcnPXA"/>
  <UMLRealTime:RTPort xmi:id="_Q3jwYO0LEeSzlZWHZcnPXA" isWired="false" base_Port="_Mt-r4O0LEeSzlZWHZcnPXA"/>
  <UMLRTStateMachines:RTState xmi:id="_jdSKAO06EeSEgM2oS3E6ZA" base_State="_hADSkMO5EeSxS9_G15_gSg"/>
  <UMLRealTime:RTConnector xmi:id="_PrTtIO1iEeSNVueSbviXfA" base_Connector="_MWa08O1iEeSNVueSbviXfA"/>
  <UMLRealTime:Capsule xmi:id="_s8nZIO1kEeSNVueSbviXfA" base_Class="_s8h5kO1kEeSNVueSbviXfA"/>
  <UMLRealTime:RTConnector xmi:id="_EgjSoO1nEeSNVueSbviXfA" base_Connector="_DVHaQO1nEeSNVueSbviXfA"/>
  <UMLRealTime:RTConnector xmi:id="_Fl6_QO1nEeSNVueSbviXfA" base_Connector="_CZ02sO1nEeSNVueSbviXfA"/>
  <UMLRealTime:CapsulePart xmi:id="_LA0hsO1nEeSNVueSbviXfA" base_Property="_3f1gQO1kEeSNVueSbviXfA"/>
  <UMLRTStateMachines:RTState xmi:id="_8_JSQO4MEeSAlbC0LA6o5Q" base_State="_rcvLcO4MEeSAlbC0LA6o5Q"/>
  <UMLRTStateMachines:RTRegion xmi:id="_Gs370O4NEeSAlbC0LA6o5Q" base_Region="_FtPDwe4NEeSAlbC0LA6o5Q"/>
  <UMLRTStateMachines:RTState xmi:id="_Q3CNQO4OEeSAlbC0LA6o5Q" base_State="_5D02wO4NEeSAlbC0LA6o5Q"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_R_gRMO4OEeSAlbC0LA6o5Q" base_Pseudostate="_KlKcAO4NEeSAlbC0LA6o5Q"/>
  <UMLRTStateMachines:RTState xmi:id="_vXVl4AuyEeWCGuiso4e4-g" base_State="_tBnrsAuyEeWCGuiso4e4-g"/>
  <UMLRealTime:RTPort xmi:id="_MjT7YAu0EeWCGuiso4e4-g" isWired="false" base_Port="_Uh604AutEeWCGuiso4e4-g"/>
  <UMLRealTime:RTPort xmi:id="_iCuewAu-EeWCGuiso4e4-g" isWired="false" base_Port="_f_gCwAu-EeWCGuiso4e4-g"/>
  <UMLRealTime:RTPort xmi:id="_QilVsA4XEeWZmqO69MGcNA" isWired="false" base_Port="_Nf-gUA4XEeWZmqO69MGcNA"/>
  <UMLRTStateMachines:RTState xmi:id="_qxXhUA4YEeWZmqO69MGcNA" base_State="_p3iWUA4YEeWZmqO69MGcNA"/>
</xmi:XMI>
